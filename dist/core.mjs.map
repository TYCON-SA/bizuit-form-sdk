{"version":3,"sources":["../src/lib/api/http-client.ts","../src/lib/api/auth-service.ts","../src/lib/utils/xml-parser.ts","../src/lib/api/process-service.ts","../src/lib/api/instance-lock-service.ts","../src/lib/utils/form-utils.ts","../src/lib/api/form-service.ts","../src/lib/api/bizuit-sdk.ts","../src/lib/utils/parameter-parser.ts","../src/lib/utils/error-handler.ts","../src/lib/utils/auth-utils.ts","../src/lib/utils/error-formatter.ts","../src/core.ts"],"sourcesContent":["/**\n * Bizuit HTTP Client\n * Axios-based client with interceptors for Bizuit API headers\n */\n\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosError } from 'axios'\nimport type { IBizuitConfig, IApiError, IBizuitAuthHeaders } from '../types'\n\nexport class BizuitHttpClient {\n  private axiosInstance: AxiosInstance\n  private config: IBizuitConfig\n\n  constructor(config: IBizuitConfig) {\n    this.config = config\n    this.axiosInstance = axios.create({\n      timeout: config.timeout || 120000, // 2 minutes default\n      headers: {\n        'Content-Type': 'application/json',\n        ...config.defaultHeaders,\n      },\n    })\n\n    this.setupInterceptors()\n  }\n\n  private setupInterceptors(): void {\n    // Request interceptor\n    this.axiosInstance.interceptors.request.use(\n      (config) => {\n        // Log requests in development\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[Bizuit API Request]', {\n            method: config.method?.toUpperCase(),\n            url: config.url,\n            headers: this.sanitizeHeaders(config.headers),\n          })\n        }\n        return config\n      },\n      (error) => {\n        return Promise.reject(this.handleError(error))\n      }\n    )\n\n    // Response interceptor\n    this.axiosInstance.interceptors.response.use(\n      (response) => {\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[Bizuit API Response]', {\n            status: response.status,\n            url: response.config.url,\n          })\n        }\n        return response\n      },\n      (error) => {\n        return Promise.reject(this.handleError(error))\n      }\n    )\n  }\n\n  private sanitizeHeaders(headers: any): Record<string, string> {\n    const sanitized: Record<string, string> = {}\n    for (const key in headers) {\n      // Hide sensitive tokens in logs\n      if (key.toLowerCase().includes('token') || key.toLowerCase().includes('auth')) {\n        sanitized[key] = '***REDACTED***'\n      } else {\n        sanitized[key] = headers[key]\n      }\n    }\n    return sanitized\n  }\n\n  private handleError(error: AxiosError): IApiError {\n    const apiError: IApiError = {\n      message: 'An unexpected error occurred',\n      statusCode: error.response?.status,\n    }\n\n    if (error.response) {\n      // Server responded with error status\n      const data = error.response.data as any\n      apiError.message = data?.message || data?.errorMessage || error.message\n      apiError.code = data?.errorType || data?.code\n      apiError.details = data\n    } else if (error.request) {\n      // Request made but no response\n      apiError.message = 'No response from server'\n      apiError.code = 'NETWORK_ERROR'\n    } else {\n      // Error in request setup\n      apiError.message = error.message\n      apiError.code = 'REQUEST_ERROR'\n    }\n\n    return apiError\n  }\n\n  /**\n   * GET request\n   */\n  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.get<T>(url, config)\n    return response.data\n  }\n\n  /**\n   * POST request\n   */\n  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.post<T>(url, data, config)\n    return response.data\n  }\n\n  /**\n   * PUT request\n   */\n  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.put<T>(url, data, config)\n    return response.data\n  }\n\n  /**\n   * PATCH request\n   */\n  async patch<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.patch<T>(url, data, config)\n    return response.data\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.delete<T>(url, config)\n    return response.data\n  }\n\n  /**\n   * Add Bizuit-specific headers to request\n   */\n  withBizuitHeaders(headers: IBizuitAuthHeaders): BizuitHttpClient {\n    const cleanHeaders: Record<string, string> = {}\n\n    Object.entries(headers).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        cleanHeaders[key] = String(value)\n      }\n    })\n\n    this.axiosInstance.defaults.headers.common = {\n      ...this.axiosInstance.defaults.headers.common,\n      ...cleanHeaders,\n    }\n\n    return this\n  }\n\n  /**\n   * Clear all Bizuit headers\n   */\n  clearBizuitHeaders(): BizuitHttpClient {\n    const bizuitHeaderPrefixes = ['BZ-']\n    const headers = this.axiosInstance.defaults.headers.common\n\n    Object.keys(headers).forEach((key) => {\n      if (bizuitHeaderPrefixes.some((prefix) => key.startsWith(prefix))) {\n        delete headers[key]\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Get raw axios instance for advanced usage\n   */\n  getAxiosInstance(): AxiosInstance {\n    return this.axiosInstance\n  }\n}\n","/**\n * Bizuit Authentication Service\n * Handles token validation, user info, and auth checks\n */\n\nimport { BizuitHttpClient } from './http-client'\nimport type {\n  IAuthCheckResponse,\n  IUserInfo,\n  IRequestCheckFormAuth,\n  ILoginSettings,\n  IBizuitConfig,\n  ILoginRequest,\n  ILoginResponse,\n} from '../types'\n\nexport class BizuitAuthService {\n  private client: BizuitHttpClient\n  private apiUrl: string\n\n  constructor(config: IBizuitConfig) {\n    this.client = new BizuitHttpClient(config)\n    this.apiUrl = config.apiUrl\n  }\n\n  /**\n   * Check form authentication and authorization\n   * Validates token and returns login configuration\n   */\n  async checkFormAuth(\n    request: IRequestCheckFormAuth,\n    token?: string\n  ): Promise<IAuthCheckResponse> {\n    const headers: Record<string, string> = {\n      'BZ-FORM-VIEWER': 'true',\n    }\n\n    if (token) {\n      headers['BZ-AUTH-TOKEN'] = token\n    }\n\n    if (request.formId) {\n      headers['BZ-FORM-ID'] = String(request.formId)\n    }\n\n    if (request.formName) {\n      headers['BZ-FORM-NAME'] = request.formName\n    }\n\n    if (request.processName) {\n      headers['BZ-PROCESS-NAME'] = request.processName\n    }\n\n    try {\n      const response = await this.client.post<IAuthCheckResponse>(\n        `${this.apiUrl}/Login/CheckFormAuth`,\n        request,\n        { headers }\n      )\n\n      return response\n    } catch (error: any) {\n      return {\n        success: false,\n        canRetry: error.statusCode !== 401,\n        errorMessage: error.message,\n        errorType: error.code,\n      }\n    }\n  }\n\n  /**\n   * Get current user information from token\n   */\n  async getUserInfo(token: string, userName: string): Promise<IUserInfo> {\n    this.client.withBizuitHeaders({\n      'BZ-AUTH-TOKEN': token,\n      'BZ-USER-NAME': userName,\n    })\n\n    const userInfo = await this.client.get<IUserInfo>(\n      `${this.apiUrl}/Login/UserInfo`\n    )\n\n    this.client.clearBizuitHeaders()\n\n    return userInfo\n  }\n\n  /**\n   * Get login configuration (OAuth, AD, etc.)\n   */\n  async getLoginConfiguration(): Promise<Partial<ILoginSettings>> {\n    const config = await this.client.get<Partial<ILoginSettings>>(\n      `${this.apiUrl}/Login/LoginConfiguration`\n    )\n\n    return config\n  }\n\n  /**\n   * Validate token and get user data\n   * Returns null if token is invalid\n   */\n  async validateToken(token: string): Promise<IUserInfo | null> {\n    try {\n      // Extract username from token (Basic auth: base64(username:password))\n      const decoded = atob(token.replace('Basic ', ''))\n      const userName = decoded.split(':')[0]\n\n      const userInfo = await this.getUserInfo(token, userName)\n      return userInfo\n    } catch (error) {\n      console.error('[BizuitAuthService] Token validation failed:', error)\n      return null\n    }\n  }\n\n  /**\n   * Check if user has required permissions\n   */\n  async checkPermissions(\n    token: string,\n    userName: string,\n    requiredRoles: string[]\n  ): Promise<boolean> {\n    try {\n      const userInfo = await this.getUserInfo(token, userName)\n\n      if (!userInfo.roles || requiredRoles.length === 0) {\n        return true\n      }\n\n      return requiredRoles.some((role) => userInfo.roles.includes(role))\n    } catch (error) {\n      console.error('[BizuitAuthService] Permission check failed:', error)\n      return false\n    }\n  }\n\n  /**\n   * Login methods (delegated to Bizuit Dashboard API)\n   */\n  async azureLogin(idToken: string, accessToken: string): Promise<any> {\n    return this.client.post(`${this.apiUrl}/Login/AzureLogin`, {\n      idToken,\n      accessToken,\n    })\n  }\n\n  async oauthLogin(code: string, redirectUri: string): Promise<any> {\n    return this.client.get(\n      `${this.apiUrl}/Login/GetOauthLoginAsync?code=${code}&redirectUri=${redirectUri}`\n    )\n  }\n\n  async socialLogin(token: string, type: 'google' | 'facebook'): Promise<any> {\n    return this.client.get(`${this.apiUrl}/Login/SocialLogin?type=${type}`, {\n      headers: {\n        Authorization: `Basic ${token}`,\n      },\n    })\n  }\n\n  /**\n   * Login with username and password\n   * Uses HTTP Basic Authentication as per Bizuit API specification\n   * Returns token and user information\n   *\n   * Example response from API:\n   * {\n   *   \"token\": \"ZMdufWTdCsSYUXj7...\",\n   *   \"user\": {\n   *     \"username\": \"admin\",\n   *     \"userID\": 1,\n   *     \"displayName\": \"Administrator Account\",\n   *     \"image\": null\n   *   },\n   *   \"forceChange\": false,\n   *   \"expirationDate\": \"2025-11-27T22:07:20.5095101Z\"\n   * }\n   */\n  async login(credentials: ILoginRequest): Promise<ILoginResponse> {\n    const { username, password } = credentials\n\n    // Create Basic Auth header: base64(username:password)\n    const authString = `${username}:${password}`\n    const base64Auth = btoa(authString)\n    const authHeader = `Basic ${base64Auth}`\n\n    try {\n      // The API returns a JSON object with token and user info\n      const response = await this.client.get<any>(\n        `${this.apiUrl}/Login`,\n        {\n          headers: {\n            'Authorization': authHeader,\n          },\n        }\n      )\n\n      // Map the API response to our ILoginResponse format\n      const loginResponse: ILoginResponse = {\n        Token: `Basic ${response.token}`, // Prepend \"Basic \" to the token\n        User: {\n          Username: response.user.username,\n          UserID: response.user.userID,\n          DisplayName: response.user.displayName,\n          Image: response.user.image,\n        },\n        ForceChange: response.forceChange,\n        ExpirationDate: response.expirationDate,\n      }\n\n      return loginResponse\n    } catch (error: any) {\n      // Handle specific error messages from API\n      if (error.statusCode === 401) {\n        throw new Error('Nombre de Usuario y/o Contraseña incorrectos.')\n      } else if (error.statusCode === 403) {\n        throw new Error('Acceso denegado, no tiene permiso para acceder.')\n      }\n\n      throw error\n    }\n  }\n}\n","/**\n * XML to JSON Converter\n * Automatically converts XML strings to JavaScript objects\n * Used by process-service to parse XML parameters\n */\n\n/**\n * Converts a tag name to camelCase\n * Example: \"DatosPersonales\" -> \"datosPersonales\"\n * Example: \"ID\" -> \"id\"\n * Example: \"IDPersonal\" -> \"idPersonal\"\n */\nfunction toCamelCase(str: string): string {\n  if (!str) return str\n\n  // If the entire string is uppercase (like \"ID\"), convert to lowercase\n  if (str === str.toUpperCase()) {\n    return str.toLowerCase()\n  }\n\n  // If string starts with multiple uppercase letters (like \"IDPersonal\"),\n  // convert them to lowercase except the last one which starts the next word\n  // IDPersonal -> idPersonal\n  // IOError -> ioError\n  const match = str.match(/^([A-Z]+)([A-Z][a-z].*)$/)\n  if (match) {\n    return match[1].toLowerCase() + match[2]\n  }\n\n  // Default case: just lowercase the first character\n  return str.charAt(0).toLowerCase() + str.slice(1)\n}\n\n/**\n * Recursively converts an XML node to a JavaScript object\n * Handles:\n * - Text content\n * - Nested elements\n * - Multiple children with same tag name (converted to arrays)\n * - Converts tag names to camelCase\n */\nfunction xmlNodeToJson(node: Element): any {\n  const obj: any = {}\n\n  // Get all child elements (excluding text nodes, comments, etc.)\n  const children = Array.from(node.children)\n\n  // If no children, return text content\n  if (children.length === 0) {\n    const textContent = node.textContent?.trim() || ''\n    return textContent\n  }\n\n  // Group children by tag name\n  const childrenByTag = new Map<string, Element[]>()\n\n  children.forEach(child => {\n    const tagName = toCamelCase(child.tagName)\n    if (!childrenByTag.has(tagName)) {\n      childrenByTag.set(tagName, [])\n    }\n    childrenByTag.get(tagName)!.push(child)\n  })\n\n  // Convert each group to JSON\n  childrenByTag.forEach((elements, tagName) => {\n    if (elements.length === 1) {\n      // Single child - convert to object\n      obj[tagName] = xmlNodeToJson(elements[0])\n    } else {\n      // Multiple children with same name - convert to array\n      obj[tagName] = elements.map(el => xmlNodeToJson(el))\n    }\n  })\n\n  return obj\n}\n\n/**\n * Converts an XML string to a JavaScript object\n *\n * @param xmlString - The XML string to parse\n * @returns JavaScript object representation of the XML, or null on error\n *\n * @example\n * ```typescript\n * const xml = `\n *   <Deudor>\n *     <DatosPersonales>\n *       <ID>75</ID>\n *       <Nombre>John Doe</Nombre>\n *     </DatosPersonales>\n *     <Contactos>\n *       <Contacto><ID>1</ID></Contacto>\n *       <Contacto><ID>2</ID></Contacto>\n *     </Contactos>\n *   </Deudor>\n * `\n *\n * const result = xmlToJson(xml)\n * // {\n * //   deudor: {\n * //     datosPersonales: {\n * //       id: \"75\",\n * //       nombre: \"John Doe\"\n * //     },\n * //     contactos: {\n * //       contacto: [\n * //         { id: \"1\" },\n * //         { id: \"2\" }\n * //       ]\n * //     }\n * //   }\n * // }\n * ```\n */\nexport function xmlToJson(xmlString: string): any | null {\n  try {\n    // Parse XML string\n    const parser = new DOMParser()\n    const xmlDoc = parser.parseFromString(xmlString, 'text/xml')\n\n    // Check for parsing errors\n    const parserError = xmlDoc.querySelector('parsererror')\n    if (parserError) {\n      console.error('XML parsing error:', parserError.textContent)\n      return null\n    }\n\n    // Get root element\n    const rootElement = xmlDoc.documentElement\n    if (!rootElement) {\n      console.error('No root element found in XML')\n      return null\n    }\n\n    // Convert root element to JSON\n    const rootTagName = toCamelCase(rootElement.tagName)\n    const result = {\n      [rootTagName]: xmlNodeToJson(rootElement)\n    }\n\n    return result\n  } catch (error) {\n    console.error('Error converting XML to JSON:', error)\n    return null\n  }\n}\n","/**\n * Bizuit Process Service\n * Handles process initialization, start and continue operations\n * Updated to match Bizuit API specification exactly\n */\n\nimport { BizuitHttpClient } from './http-client'\nimport type {\n  IBizuitConfig,\n  IInitializeParams,\n  IProcessData,\n  IStartProcessParams,\n  IProcessResult,\n} from '../types'\nimport { xmlToJson } from '../utils/xml-parser'\n\nexport class BizuitProcessService {\n  private client: BizuitHttpClient\n  private apiUrl: string\n\n  constructor(config: IBizuitConfig) {\n    this.client = new BizuitHttpClient(config)\n    this.apiUrl = config.apiUrl\n  }\n\n  /**\n   * Initialize process - Get parameters for new or existing instance\n   * Uses standard Authorization header as per API specification\n   */\n  async initialize(params: IInitializeParams): Promise<IProcessData> {\n    const queryParams = new URLSearchParams()\n    queryParams.append('processName', params.processName)\n\n    if (params.activityName) queryParams.append('activityName', params.activityName)\n    if (params.version) queryParams.append('version', params.version)\n    if (params.instanceId) queryParams.append('instanceId', params.instanceId)\n\n    const headers: Record<string, string> = {}\n\n    // Use standard Authorization header with token\n    if (params.token) {\n      headers['Authorization'] = params.token\n    }\n\n    if (params.sessionToken) {\n      headers['BZ-SESSION-TOKEN'] = params.sessionToken\n    }\n\n    if (params.userName) {\n      headers['BZ-USER-NAME'] = params.userName\n    }\n\n    if (params.formId) {\n      headers['BZ-FORM'] = String(params.formId)\n    }\n\n    if (params.formDraftId) {\n      headers['BZ-DRAFT-FORM'] = String(params.formDraftId)\n    }\n\n    if (params.processName) {\n      headers['BZ-PROCESS-NAME'] = params.processName\n    }\n\n    if (params.instanceId) {\n      headers['BZ-INSTANCEID'] = params.instanceId\n    }\n\n    if (params.childProcessName) {\n      headers['BZ-CHILD-PROCESS-NAME'] = params.childProcessName\n    }\n\n    const processData = await this.client.get<IProcessData>(\n      `${this.apiUrl}/Process/Initialize?${queryParams.toString()}`,\n      { headers }\n    )\n\n    return processData\n  }\n\n  /**\n   * Start process - Execute process or start new instance\n   * Sends JSON directly as per Bizuit API specification\n   *\n   * Example from curl:\n   * POST /api/instances\n   * Authorization: Basic TOKEN\n   * Content-Type: application/json\n   * {\n   *   \"eventName\": \"DemoFlow\",\n   *   \"parameters\": [\n   *     {\n   *       \"name\": \"pData\",\n   *       \"value\": \"A\",\n   *       \"type\": \"SingleValue\",\n   *       \"direction\": \"In\"\n   *     }\n   *   ]\n   * }\n   */\n  async start(\n    params: IStartProcessParams,\n    files?: File[],\n    token?: string\n  ): Promise<IProcessResult> {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    }\n\n    // Use standard Authorization header with token\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    // Build the payload exactly as the API expects\n    const payload: any = {\n      eventName: params.processName,\n      parameters: params.parameters || [],\n    }\n\n    // Add optional fields only if provided\n    if (params.instanceId) {\n      payload.instanceId = params.instanceId\n    }\n\n    if (params.processVersion) {\n      payload.eventVersion = params.processVersion\n    }\n\n    if (params.closeOnSuccess !== undefined) {\n      payload.closeOnSuccess = params.closeOnSuccess\n    }\n\n    if (params.deletedDocuments && params.deletedDocuments.length > 0) {\n      payload.deletedDocuments = params.deletedDocuments\n    }\n\n    // Note: File upload support would require multipart/form-data\n    // For now, we're implementing JSON-only as per the curl examples\n    if (files && files.length > 0) {\n      console.warn('File upload in start is not yet implemented in JSON mode')\n    }\n\n    const result = await this.client.post<IProcessResult>(\n      `${this.apiUrl}/instances`,\n      payload,\n      { headers }\n    )\n\n    // Automatically parse XML parameters to JSON\n    // Note: API returns tyconParameters, but we map it to parameters\n    const parametersArray = (result as any).tyconParameters || result.parameters;\n    if (parametersArray && Array.isArray(parametersArray)) {\n      parametersArray.forEach((param: any) => {\n        // Check if parameter type is 2 or \"Xml\" (XML/Complex) and has a value\n        if ((param.parameterType === 2 || param.parameterType === 'Xml') && param.value) {\n          try {\n            const parsedJson = xmlToJson(param.value)\n            if (parsedJson !== null) {\n              // Replace XML string with parsed JSON object\n              param.value = parsedJson as any\n              // Change parameterType to indicate it's now JSON\n              param.parameterType = 'Json' as any\n              console.log(`✅ Auto-parsed XML parameter: ${param.name}`)\n            } else {\n              console.warn(`⚠️ Failed to parse XML parameter: ${param.name}, keeping original XML`)\n            }\n          } catch (error) {\n            console.warn(`⚠️ Error parsing XML parameter ${param.name}:`, error)\n            // Keep original XML value on error\n          }\n        }\n      })\n\n      // Map tyconParameters to parameters for compatibility\n      if ((result as any).tyconParameters) {\n        result.parameters = parametersArray;\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Get process parameters schema\n   * Useful for dynamic form generation\n   *\n   * Example:\n   * GET /api/eventmanager/workflowDefinition/parameters/{processName}?version={version}\n   * Authorization: Basic TOKEN\n   *\n   * Returns array of parameters with:\n   * - parameterType: 1 (SingleValue) or 2 (Xml)\n   * - parameterDirection: 1 (In), 2 (Out), 3 (Optional)\n   * - name, type, schema, isSystemParameter, isVariable\n   */\n  async getParameters(\n    processName: string,\n    version?: string,\n    token?: string\n  ): Promise<any[]> {\n    const headers: Record<string, string> = {}\n\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    const queryParams = new URLSearchParams()\n    // Always add version parameter, even if empty (API requires it)\n    queryParams.append('version', version || '')\n\n    const url = `${this.apiUrl}/eventmanager/workflowDefinition/parameters/${processName}?${queryParams.toString()}`\n\n    const parameters = await this.client.get<any[]>(url, { headers })\n\n    return parameters\n  }\n\n  /**\n   * Get instance data\n   * Uses standard Authorization header\n   *\n   * Example from curl:\n   * GET /api/instances?instanceId=8d2d0e04-ea83-48f2-953d-ff858581e3df\n   * Authorization: Basic TOKEN\n   */\n  async getInstanceData(\n    instanceId: string,\n    token?: string\n  ): Promise<IProcessData> {\n    const headers: Record<string, string> = {}\n\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    const data = await this.client.get<IProcessData>(\n      `${this.apiUrl}/instances?instanceId=${instanceId}`,\n      { headers }\n    )\n\n    return data\n  }\n\n  /**\n   * Acquire pessimistic lock on instance\n   * Prevents concurrent editing\n   */\n  async acquireLock(params: {\n    instanceId: string\n    token: string\n  }): Promise<{ sessionToken: string; processData: IProcessData }> {\n    const headers: Record<string, string> = {\n      'Authorization': params.token,\n    }\n\n    const result = await this.client.post<{ sessionToken: string; processData: IProcessData }>(\n      `${this.apiUrl}/ProcessInstance/AcquireLock`,\n      { instanceId: params.instanceId },\n      { headers }\n    )\n\n    return result\n  }\n\n  /**\n   * Release pessimistic lock on instance\n   */\n  async releaseLock(params: {\n    instanceId: string\n    sessionToken: string\n  }): Promise<void> {\n    const headers: Record<string, string> = {\n      'BZ-SESSION-TOKEN': params.sessionToken,\n    }\n\n    await this.client.post<void>(\n      `${this.apiUrl}/ProcessInstance/ReleaseLock`,\n      { instanceId: params.instanceId },\n      { headers }\n    )\n  }\n\n  /**\n   * Continue instance with updated parameters\n   * Uses PUT method instead of POST\n   *\n   * Example from curl:\n   * PUT /api/instances\n   * Authorization: Basic TOKEN\n   * Content-Type: application/json\n   * {\n   *   \"eventName\": \"DemoFlow\",\n   *   \"parameters\": [...],\n   *   \"instanceId\": \"e3137f94-0ab5-4ae7-b256-10806fe92958\"\n   * }\n   */\n  async continue(\n    params: IStartProcessParams,\n    files?: File[],\n    token?: string\n  ): Promise<IProcessResult> {\n    if (!params.instanceId) {\n      throw new Error('instanceId is required for continue')\n    }\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    }\n\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    const payload: any = {\n      eventName: params.processName,\n      parameters: params.parameters || [],\n      instanceId: params.instanceId,\n    }\n\n    if (params.processVersion) {\n      payload.eventVersion = params.processVersion\n    }\n\n    if (params.closeOnSuccess !== undefined) {\n      payload.closeOnSuccess = params.closeOnSuccess\n    }\n\n    if (params.deletedDocuments && params.deletedDocuments.length > 0) {\n      payload.deletedDocuments = params.deletedDocuments\n    }\n\n    if (files && files.length > 0) {\n      console.warn('File upload in continue is not yet implemented in JSON mode')\n    }\n\n    const result = await this.client.put<IProcessResult>(\n      `${this.apiUrl}/instances`,\n      payload,\n      { headers }\n    )\n\n    // Automatically parse XML parameters to JSON\n    // Note: API returns tyconParameters, but we map it to parameters\n    const parametersArray = (result as any).tyconParameters || result.parameters;\n    if (parametersArray && Array.isArray(parametersArray)) {\n      parametersArray.forEach((param: any) => {\n        // Check if parameter type is 2 or \"Xml\" (XML/Complex) and has a value\n        if ((param.parameterType === 2 || param.parameterType === 'Xml') && param.value) {\n          try {\n            const parsedJson = xmlToJson(param.value)\n            if (parsedJson !== null) {\n              // Replace XML string with parsed JSON object\n              param.value = parsedJson as any\n              // Change parameterType to indicate it's now JSON\n              param.parameterType = 'Json' as any\n              console.log(`✅ Auto-parsed XML parameter: ${param.name}`)\n            } else {\n              console.warn(`⚠️ Failed to parse XML parameter: ${param.name}, keeping original XML`)\n            }\n          } catch (error) {\n            console.warn(`⚠️ Error parsing XML parameter ${param.name}:`, error)\n            // Keep original XML value on error\n          }\n        }\n      })\n\n      // Map tyconParameters to parameters for compatibility\n      if ((result as any).tyconParameters) {\n        result.parameters = parametersArray;\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Get Bizuit configuration settings for an organization\n   * @param organizationId - Organization identifier\n   * @param token - Authentication token\n   * @returns Configuration settings object\n   */\n  async getConfigurationSettings(\n    organizationId: string,\n    token?: string\n  ): Promise<Record<string, any>> {\n    const headers: Record<string, string> = {}\n\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    const result = await this.client.get<Record<string, any>>(\n      `${this.apiUrl}/bpmn/configuration-settings?organizationId=${organizationId}`,\n      { headers }\n    )\n\n    return result\n  }\n}\n","/**\n * Bizuit Instance Lock Service\n * Handles pessimistic locking for process instances\n */\n\nimport { BizuitHttpClient } from './http-client'\nimport type {\n  IBizuitConfig,\n  ILockStatus,\n  ILockRequest,\n  IUnlockRequest,\n} from '../types'\n\nexport class BizuitInstanceLockService {\n  private client: BizuitHttpClient\n  private apiUrl: string\n\n  constructor(config: IBizuitConfig) {\n    this.client = new BizuitHttpClient(config)\n    this.apiUrl = config.apiUrl\n  }\n\n  /**\n   * Check if instance is locked\n   */\n  async checkLockStatus(\n    instanceId: string,\n    activityName: string,\n    token: string\n  ): Promise<ILockStatus> {\n    this.client.withBizuitHeaders({\n      'BZ-AUTH-TOKEN': token,\n    })\n\n    const status = await this.client.get<boolean>(\n      `${this.apiUrl}/instances/status/${instanceId}?activityName=${activityName}`\n    )\n\n    this.client.clearBizuitHeaders()\n\n    return {\n      available: status,\n    }\n  }\n\n  /**\n   * Lock instance for editing\n   */\n  async lock(\n    request: ILockRequest,\n    token: string\n  ): Promise<ILockStatus> {\n    this.client.withBizuitHeaders({\n      'BZ-AUTH-TOKEN': token,\n    })\n\n    const queryParams = new URLSearchParams({\n      activityName: request.activityName,\n      operation: String(request.operation),\n      processName: request.processName,\n    })\n\n    const result = await this.client.patch<ILockStatus>(\n      `${this.apiUrl}/instances/lock/${request.instanceId}?${queryParams.toString()}`\n    )\n\n    this.client.clearBizuitHeaders()\n\n    return result\n  }\n\n  /**\n   * Unlock instance\n   */\n  async unlock(\n    request: IUnlockRequest,\n    token: string\n  ): Promise<ILockStatus> {\n    this.client.withBizuitHeaders({\n      'BZ-AUTH-TOKEN': token,\n    })\n\n    const result = await this.client.patch<ILockStatus>(\n      `${this.apiUrl}/instances/unlock/${request.instanceId}`,\n      request\n    )\n\n    this.client.clearBizuitHeaders()\n\n    return result\n  }\n\n  /**\n   * Execute a callback with automatic lock/unlock\n   * Ensures instance is always unlocked even if callback throws\n   */\n  async withLock<T>(\n    request: ILockRequest,\n    token: string,\n    callback: (sessionToken: string) => Promise<T>\n  ): Promise<T> {\n    // Lock instance\n    const lockResult = await this.lock(request, token)\n\n    if (!lockResult.available) {\n      throw new Error(\n        `Instance is locked by ${lockResult.user}. Reason: ${lockResult.reason}`\n      )\n    }\n\n    const sessionToken = lockResult.sessionToken || ''\n\n    try {\n      // Execute callback\n      const result = await callback(sessionToken)\n      return result\n    } finally {\n      // Always unlock, even if callback throws\n      try {\n        await this.unlock(\n          {\n            instanceId: request.instanceId,\n            activityName: request.activityName,\n            sessionToken,\n          },\n          token\n        )\n      } catch (unlockError) {\n        console.error('[BizuitInstanceLockService] Failed to unlock instance:', unlockError)\n      }\n    }\n  }\n\n  /**\n   * Force unlock (admin only)\n   * Use with caution\n   */\n  async forceUnlock(\n    instanceId: string,\n    activityName: string,\n    token: string\n  ): Promise<void> {\n    await this.unlock(\n      {\n        instanceId,\n        activityName,\n      },\n      token\n    )\n  }\n}\n","/**\n * Form utilities for converting form data to Bizuit API format\n */\n\nimport type { IParameter } from '../types'\n\n/**\n * Bizuit Process Parameter from API\n * Structure returned by getProcessParameters endpoint\n */\nexport interface IBizuitProcessParameter {\n  name: string\n  parameterType: number // 1 = SingleValue, 2 = Xml\n  parameterDirection: number // 1 = In, 2 = Out, 3 = Optional\n  type: string // 'string', 'int', 'bool', etc.\n  schema: string // XSD schema\n  value: string | null\n  isSystemParameter: boolean\n  isVariable: boolean\n}\n\n/**\n * Filters process parameters to get only those that should be displayed in the START PROCESS form\n * Excludes system parameters, variables, and output-only parameters\n *\n * @param parameters - Array of process parameters from getProcessParameters\n * @returns Filtered array of parameters for START process form display\n *\n * @example\n * ```typescript\n * const allParams = await sdk.process.getProcessParameters('MyProcess', '', token)\n * const formParams = filterFormParameters(allParams)\n * // Returns only input (direction=1) and optional (direction=3) parameters\n * // that are not system parameters or variables\n * ```\n */\nexport function filterFormParameters(\n  parameters: IBizuitProcessParameter[]\n): IBizuitProcessParameter[] {\n  return parameters.filter((param) => {\n    // Exclude system parameters and variables\n    if (param.isSystemParameter || param.isVariable) {\n      return false\n    }\n\n    // Include only Input (1) and Optional (3) parameters\n    // Exclude Output (2) parameters\n    return param.parameterDirection === 1 || param.parameterDirection === 3\n  })\n}\n\n/**\n * Filters process parameters to get only those that should be displayed in the CONTINUE PROCESS form\n * Includes Input, Optional, AND Variables (different from filterFormParameters)\n * Excludes only system parameters and output-only parameters\n *\n * @param parameters - Array of process parameters from getProcessParameters\n * @returns Filtered array of parameters for CONTINUE process form display\n *\n * @example\n * ```typescript\n * const allParams = await sdk.process.getProcessParameters('MyProcess', '', token)\n * const formParams = filterContinueParameters(allParams)\n * // Returns input (direction=1), optional (direction=3) parameters,\n * // AND variables (isVariable=true) that are not system parameters\n * ```\n */\nexport function filterContinueParameters(\n  parameters: IBizuitProcessParameter[]\n): IBizuitProcessParameter[] {\n  return parameters.filter((param) => {\n    // Exclude system parameters\n    if (param.isSystemParameter) {\n      return false\n    }\n\n    // Include Variables (this is the main difference from filterFormParameters)\n    if (param.isVariable) {\n      return true\n    }\n\n    // Include Input (1) and Optional (3) parameters\n    // Exclude Output-only (2) parameters\n    return param.parameterDirection === 1 || param.parameterDirection === 3\n  })\n}\n\n/**\n * Checks if a parameter is required or optional\n *\n * @param param - Process parameter\n * @returns true if parameter is required (direction=1), false if optional (direction=3)\n */\nexport function isParameterRequired(param: IBizuitProcessParameter): boolean {\n  return param.parameterDirection === 1\n}\n\n/**\n * Gets a human-readable label for parameter direction\n *\n * @param direction - Parameter direction number\n * @returns Human-readable label\n */\nexport function getParameterDirectionLabel(direction: number): string {\n  switch (direction) {\n    case 1:\n      return 'Input'\n    case 2:\n      return 'Output'\n    case 3:\n      return 'Optional'\n    default:\n      return 'Unknown'\n  }\n}\n\n/**\n * Gets a human-readable label for parameter type\n *\n * @param parameterType - Parameter type number\n * @returns Human-readable label\n */\nexport function getParameterTypeLabel(parameterType: number): string {\n  switch (parameterType) {\n    case 1:\n      return 'SingleValue'\n    case 2:\n      return 'Xml'\n    default:\n      return 'Unknown'\n  }\n}\n\n/**\n * Converts form data to IParameter[] format expected by Bizuit API\n *\n * @param formData - Object with form field values\n * @returns Array of IParameter objects\n *\n * @example\n * ```typescript\n * const formData = {\n *   priority: 'high',\n *   categories: ['sales', 'support'],\n *   startDate: new Date(),\n *   budget: 75,\n *   description: 'Process description',\n *   files: [file1, file2]\n * }\n *\n * const parameters = formDataToParameters(formData)\n * // Returns:\n * // [\n * //   { name: 'priority', value: 'high', type: 'SingleValue', direction: 'In' },\n * //   { name: 'categories', value: '[\"sales\",\"support\"]', type: 'SingleValue', direction: 'In' },\n * //   ...\n * // ]\n * ```\n */\nexport function formDataToParameters(formData: Record<string, any>): IParameter[] {\n  const parameters: IParameter[] = []\n\n  for (const [key, value] of Object.entries(formData)) {\n    // Skip undefined, null, or empty values\n    if (value === undefined || value === null || value === '') {\n      continue\n    }\n\n    // Skip file objects - files are handled separately in the SDK\n    if (value instanceof File || (Array.isArray(value) && value.length > 0 && value[0] instanceof File)) {\n      continue\n    }\n\n    // Convert value to string based on type\n    let stringValue: string\n    let paramType: 'SingleValue' | 'Xml' | 'ComplexObject' = 'SingleValue'\n\n    if (Array.isArray(value)) {\n      // Array values: convert to JSON string\n      stringValue = JSON.stringify(value)\n    } else if (value instanceof Date) {\n      // Date values: convert to ISO string\n      stringValue = value.toISOString()\n    } else if (typeof value === 'object') {\n      // Complex objects: convert to JSON string and mark as ComplexObject\n      stringValue = JSON.stringify(value)\n      paramType = 'ComplexObject'\n    } else if (typeof value === 'boolean') {\n      // Boolean values: convert to 'true' or 'false' string\n      stringValue = value.toString()\n    } else {\n      // Primitive values: convert to string\n      stringValue = String(value)\n    }\n\n    parameters.push({\n      name: key,\n      value: stringValue,\n      type: paramType,\n      direction: 'In',\n    })\n  }\n\n  return parameters\n}\n\n/**\n * Converts IParameter[] back to form data object\n * Useful for loading existing instance data into the form\n *\n * @param parameters - Array of IParameter objects\n * @returns Object with form field values\n *\n * @example\n * ```typescript\n * const parameters = [\n *   { name: 'priority', value: 'high', type: 'SingleValue', direction: 'In' },\n *   { name: 'categories', value: '[\"sales\",\"support\"]', type: 'SingleValue', direction: 'In' }\n * ]\n *\n * const formData = parametersToFormData(parameters)\n * // Returns: { priority: 'high', categories: ['sales', 'support'] }\n * ```\n */\nexport function parametersToFormData(parameters: IParameter[]): Record<string, any> {\n  const formData: Record<string, any> = {}\n\n  for (const param of parameters) {\n    if (!param.value) continue\n\n    try {\n      // Try to parse as JSON first (for arrays and objects)\n      const parsedValue = JSON.parse(param.value)\n      formData[param.name] = parsedValue\n    } catch {\n      // If parsing fails, it's a simple string value\n      // Try to detect if it's a date\n      if (isISODate(param.value)) {\n        formData[param.name] = new Date(param.value)\n      } else if (param.value === 'true' || param.value === 'false') {\n        // Convert string boolean to actual boolean\n        formData[param.name] = param.value === 'true'\n      } else if (!isNaN(Number(param.value)) && param.value.trim() !== '') {\n        // Convert numeric strings to numbers\n        formData[param.name] = Number(param.value)\n      } else {\n        // Keep as string\n        formData[param.name] = param.value\n      }\n    }\n  }\n\n  return formData\n}\n\n/**\n * Helper function to detect if a string is an ISO date\n */\nfunction isISODate(str: string): boolean {\n  const isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/\n  return isoDateRegex.test(str)\n}\n\n/**\n * Creates a parameter with explicit type and direction\n * Useful for creating specific parameters that need custom configuration\n *\n * @param name - Parameter name\n * @param value - Parameter value\n * @param type - Parameter type (default: 'SingleValue')\n * @param direction - Parameter direction (default: 'In')\n * @returns IParameter object\n *\n * @example\n * ```typescript\n * const param = createParameter('userId', '12345', 'SingleValue', 'In')\n * ```\n */\nexport function createParameter(\n  name: string,\n  value: any,\n  type: 'SingleValue' | 'Xml' | 'ComplexObject' = 'SingleValue',\n  direction: 'In' | 'Out' | 'InOut' = 'In'\n): IParameter {\n  return {\n    name,\n    value: typeof value === 'string' ? value : JSON.stringify(value),\n    type,\n    direction,\n  }\n}\n\n/**\n * Merges multiple parameter arrays, with later arrays overriding earlier ones\n * Useful for combining default parameters with form data\n *\n * @param parameterArrays - Arrays of parameters to merge\n * @returns Merged array of parameters\n *\n * @example\n * ```typescript\n * const defaults = [{ name: 'status', value: 'pending', type: 'SingleValue', direction: 'In' }]\n * const formParams = formDataToParameters(formData)\n * const merged = mergeParameters(defaults, formParams)\n * ```\n */\nexport function mergeParameters(...parameterArrays: IParameter[][]): IParameter[] {\n  const paramMap = new Map<string, IParameter>()\n\n  for (const params of parameterArrays) {\n    for (const param of params) {\n      paramMap.set(param.name, param)\n    }\n  }\n\n  return Array.from(paramMap.values())\n}\n\n/**\n * Lock information returned by loadInstanceDataForContinue\n */\nexport interface ILockInfo {\n  /** Whether the instance is currently locked by this user */\n  isLocked: boolean\n  /** Session token for unlocking (only present if isLocked is true) */\n  sessionToken?: string\n  /** User who has the lock (only present if locked by another user) */\n  lockedBy?: string\n  /** Reason for lock failure (only present if lock failed) */\n  lockFailReason?: string\n}\n\n/**\n * Result type for loadInstanceDataForContinue helper\n */\nexport interface ILoadInstanceDataResult {\n  instanceData: any\n  processName: string\n  eventName: string\n  formParameters: IBizuitProcessParameter[]\n  formData: Record<string, any>\n  /** Lock information (only present if autoLock was requested) */\n  lockInfo?: ILockInfo\n}\n\n/**\n * Maps Bizuit API parameter structure to IBizuitProcessParameter format\n * API returns different field names and structure\n */\nfunction mapApiParameterToInternal(apiParam: any): IParameter {\n  return {\n    name: apiParam.name,\n    value: typeof apiParam.value === 'object' ? JSON.stringify(apiParam.value) : String(apiParam.value || ''),\n    type: apiParam.parameterType === 'SingleValue' ? 'SingleValue' : apiParam.parameterType === 'Xml' ? 'Xml' : 'SingleValue',\n    direction: apiParam.parameterDirection === 'In' ? 'In' : apiParam.parameterDirection === 'Out' ? 'Out' : apiParam.parameterDirection === 'Optional' ? 'InOut' : 'In',\n  }\n}\n\n/**\n * Converts API parameter structure to IBizuitProcessParameter\n * for form rendering\n */\nfunction mapApiParameterToFormParameter(apiParam: any): IBizuitProcessParameter {\n  // Map parameterDirection string to number\n  let direction = 1 // Default In\n  if (apiParam.parameterDirection === 'Out') direction = 2\n  else if (apiParam.parameterDirection === 'Optional') direction = 3\n  else if (apiParam.parameterDirection === 'In') direction = 1\n\n  // Map parameterType\n  let paramType = 1 // Default SingleValue\n  if (apiParam.parameterType === 'Xml') paramType = 2\n\n  return {\n    name: apiParam.name,\n    parameterType: paramType,\n    parameterDirection: direction,\n    type: guessTypeFromValue(apiParam.value),\n    schema: '',\n    value: typeof apiParam.value === 'object' ? JSON.stringify(apiParam.value) : String(apiParam.value || ''),\n    isSystemParameter: apiParam.name === 'InstanceId' || apiParam.name === 'LoggedUser' || apiParam.name === 'ExceptionParameter',\n    isVariable: false, // API doesn't distinguish, assume false for now\n  }\n}\n\n/**\n * Guess data type from value for form rendering\n */\nfunction guessTypeFromValue(value: any): string {\n  if (value === null || value === undefined || value === '') return 'string'\n  if (typeof value === 'boolean') return 'bool'\n  if (typeof value === 'number') return 'int'\n  if (typeof value === 'object') return 'string' // Will be JSON\n\n  // Try to parse as number\n  if (!isNaN(Number(value)) && value.toString().trim() !== '') return 'int'\n\n  return 'string'\n}\n\n/**\n * Options for loadInstanceDataForContinue helper\n */\nexport interface ILoadInstanceDataOptions {\n  /** Instance ID to load */\n  instanceId: string\n  /** Activity name (required if autoLock is true) */\n  activityName?: string\n  /** Process name (required if autoLock is true) */\n  processName?: string\n  /** Automatically acquire lock for editing (default: false) */\n  autoLock?: boolean\n  /** Lock operation type (default: 1 = Edit) */\n  lockOperation?: number\n}\n\n/**\n * Helper function to load all necessary data for continuing a process instance\n * This encapsulates the business logic of:\n * 1. Getting instance data with parameters\n * 2. Converting API parameters to form-friendly format\n * 3. Filtering editable parameters (excludes Output-only and system params)\n * 4. Parsing existing parameter values into form data\n * 5. Optionally acquiring a pessimistic lock for editing\n *\n * @param sdk - Bizuit SDK instance with process and lock services\n * @param options - Configuration options\n * @param token - Authentication token\n * @returns Promise with all data needed to render continue form\n *\n * @example\n * ```typescript\n * // Load without lock (read-only)\n * const result = await loadInstanceDataForContinue(sdk, {\n *   instanceId: '123-456-789'\n * }, token)\n *\n * // Load with automatic lock (for editing)\n * const result = await loadInstanceDataForContinue(sdk, {\n *   instanceId: '123-456-789',\n *   activityName: 'ReviewTask',\n *   processName: 'ApprovalProcess',\n *   autoLock: true\n * }, token)\n *\n * // Check lock status\n * if (result.lockInfo?.isLocked) {\n *   console.log('Locked with session:', result.lockInfo.sessionToken)\n * }\n * ```\n */\nexport async function loadInstanceDataForContinue(\n  sdk: any, // TODO: Type this properly as BizuitSDK\n  options: string | ILoadInstanceDataOptions, // Support old API (string) and new API (options object)\n  token: string\n): Promise<ILoadInstanceDataResult> {\n  // Handle backward compatibility: if options is a string, treat it as instanceId\n  const opts: ILoadInstanceDataOptions = typeof options === 'string'\n    ? { instanceId: options, autoLock: false }\n    : options\n\n  const { instanceId, activityName, processName, autoLock = false, lockOperation = 1 } = opts\n\n  // 1. Get instance data\n  const instanceData = await sdk.process.getInstanceData(instanceId, token)\n\n  let formParameters: IBizuitProcessParameter[] = []\n  let formData: Record<string, any> = {}\n  let lockInfo: ILockInfo | undefined\n\n  // 2. Parse parameters from API response\n  // API structure: results.tyconParameters.tyconParameter[]\n  const apiParameters = instanceData?.results?.tyconParameters?.tyconParameter\n\n  if (apiParameters && Array.isArray(apiParameters)) {\n    // Convert API structure to IBizuitProcessParameter[]\n    const allParams = apiParameters.map(mapApiParameterToFormParameter)\n\n    // Filter for continue form (excludes Output-only and system params)\n    formParameters = allParams.filter(param => {\n      // Exclude system parameters\n      if (param.isSystemParameter) return false\n\n      // Exclude Output-only (direction = 2)\n      if (param.parameterDirection === 2) return false\n\n      // Include Input (1), Optional (3), and Variables\n      return true\n    })\n\n    // Convert API parameter structure to IParameter[] for form data\n    const parameters = apiParameters.map(mapApiParameterToInternal)\n    formData = parametersToFormData(parameters)\n  }\n\n  // 3. Optionally acquire lock for editing\n  if (autoLock) {\n    if (!activityName || !processName) {\n      throw new Error('activityName and processName are required when autoLock is true')\n    }\n\n    try {\n      // Try to acquire lock\n      const lockResult = await sdk.lock.lock(\n        {\n          instanceId,\n          activityName,\n          processName,\n          operation: lockOperation,\n        },\n        token\n      )\n\n      if (lockResult.available) {\n        lockInfo = {\n          isLocked: true,\n          sessionToken: lockResult.sessionToken,\n        }\n      } else {\n        lockInfo = {\n          isLocked: false,\n          lockedBy: lockResult.user,\n          lockFailReason: lockResult.reason || 'Instance is locked by another user',\n        }\n      }\n    } catch (err: any) {\n      // Lock failed - provide error info but don't throw\n      // This allows the app to decide how to handle lock failures\n      lockInfo = {\n        isLocked: false,\n        lockFailReason: err.message || 'Failed to acquire lock',\n      }\n    }\n  }\n\n  return {\n    instanceData,\n    processName: processName || '', // Use provided processName if available\n    eventName: '', // Must be provided by user separately\n    formParameters,\n    formData,\n    lockInfo,\n  }\n}\n\n/**\n * Release a lock acquired by loadInstanceDataForContinue\n *\n * This is a convenience helper that wraps sdk.lock.unlock().\n * Use this to release locks when canceling edits or after successful submit.\n *\n * @param sdk - Bizuit SDK instance with lock service\n * @param options - Lock release options\n * @param token - Authentication token\n * @returns Promise that resolves when lock is released\n *\n * @example\n * ```typescript\n * // After loading with lock\n * const result = await loadInstanceDataForContinue(sdk, {\n *   instanceId: '123',\n *   activityName: 'Task',\n *   processName: 'Process',\n *   autoLock: true\n * }, token)\n *\n * // ... user cancels or finishes editing ...\n *\n * // Release the lock\n * if (result.lockInfo?.sessionToken) {\n *   await releaseInstanceLock(sdk, {\n *     instanceId: '123',\n *     activityName: 'Task',\n *     sessionToken: result.lockInfo.sessionToken\n *   }, token)\n * }\n * ```\n */\nexport async function releaseInstanceLock(\n  sdk: any,\n  options: {\n    instanceId: string\n    activityName: string\n    sessionToken: string\n  },\n  token: string\n): Promise<void> {\n  try {\n    await sdk.lock.unlock(options, token)\n  } catch (err: any) {\n    // Silently fail - lock will expire eventually\n    if (process.env.NODE_ENV === 'development') {\n      console.warn('[releaseInstanceLock] Failed to release lock:', err.message)\n    }\n  }\n}\n\n/**\n * Processes a URL token and creates a mock login response\n * This is useful when Bizuit BPM passes a token via URL parameter\n *\n * @param token - The authentication token from URL\n * @param username - Optional username (defaults to 'bizuit-user')\n * @param displayName - Optional display name (defaults to 'Usuario Bizuit')\n * @param expirationHours - Token expiration in hours (defaults to 24)\n * @returns ILoginResponse object ready for auth context\n *\n * @example\n * ```typescript\n * import { processUrlToken } from '@bizuit/form-sdk'\n *\n * const urlToken = searchParams.get('token')\n * if (urlToken) {\n *   const loginResponse = processUrlToken(urlToken)\n *   setAuthData(loginResponse)\n * }\n * ```\n */\nexport function processUrlToken(\n  token: string,\n  username: string = 'bizuit-user',\n  displayName: string = 'Usuario Bizuit',\n  expirationHours: number = 24\n): {\n  Token: string\n  User: {\n    Username: string\n    UserID: number\n    DisplayName: string\n  }\n  ExpirationDate: string\n} {\n  return {\n    Token: token,\n    User: {\n      Username: username,\n      UserID: 0,\n      DisplayName: displayName,\n    },\n    ExpirationDate: new Date(Date.now() + expirationHours * 60 * 60 * 1000).toISOString(),\n  }\n}\n\n/**\n * Parameter mapping configuration\n * Maps form fields to Bizuit parameters/variables with optional transformation\n */\nexport interface IParameterMapping {\n  /** Name of the Bizuit parameter or variable */\n  parameterName: string\n  /** Whether this is a variable (true) or parameter (false). Default: false */\n  isVariable?: boolean\n  /** Optional function to transform the form value before sending */\n  transform?: (value: any) => any\n  /** Parameter type. Default: 'SingleValue' */\n  type?: 'SingleValue' | 'Xml' | 'ComplexObject'\n  /** Parameter direction. Default: 'In' */\n  direction?: 'In' | 'Out' | 'InOut'\n}\n\n/**\n * Builds parameters array by selectively mapping form fields to Bizuit parameters/variables\n *\n * This function gives you complete control over which form fields are sent as parameters,\n * allowing you to:\n * - Map form field names to different parameter names\n * - Specify which fields are variables vs parameters\n * - Transform values before sending\n * - Send only specific fields instead of all form data\n *\n * @param mapping - Object mapping form field names to parameter configuration\n * @param formData - Form data object\n * @returns Array of IParameter objects ready for Bizuit API\n *\n * @example\n * ```typescript\n * // Map form fields to parameters and variables\n * const parameters = buildParameters({\n *   // Simple mapping: form field 'empleado' → parameter 'pEmpleado'\n *   'empleado': {\n *     parameterName: 'pEmpleado'\n *   },\n *\n *   // Map to different name with transformation\n *   'monto': {\n *     parameterName: 'pMonto',\n *     transform: (val) => parseFloat(val).toFixed(2)\n *   },\n *\n *   // Map to a variable (for continue process)\n *   'aprobado': {\n *     parameterName: 'vAprobado',\n *     isVariable: true\n *   },\n *\n *   // Complex object with custom type\n *   'detalles': {\n *     parameterName: 'pDetalles',\n *     type: 'ComplexObject'\n *   }\n * }, formData)\n *\n * // Only fields in mapping are included, all others are ignored\n * ```\n *\n * @example\n * ```typescript\n * // Continue process with selective fields\n * const parameters = buildParameters({\n *   // Only send these 2 fields, ignore all others\n *   'comentarios': { parameterName: 'pComentarios' },\n *   'estadoAprobacion': {\n *     parameterName: 'vEstado',\n *     isVariable: true\n *   }\n * }, formData)\n *\n * await sdk.process.raiseEvent({\n *   eventName: 'AprobacionVacaciones',\n *   instanceId: 'existing-instance-id',\n *   parameters\n * }, [], token)\n * ```\n */\nexport function buildParameters(\n  mapping: Record<string, IParameterMapping>,\n  formData: Record<string, any>\n): IParameter[] {\n  const parameters: IParameter[] = []\n\n  // Iterate over the mapping (not formData) to ensure we only include mapped fields\n  for (const [formFieldName, config] of Object.entries(mapping)) {\n    // Get value from form data\n    let value = formData[formFieldName]\n\n    // Skip if value doesn't exist in form data\n    if (value === undefined) {\n      continue\n    }\n\n    // Skip null or empty values (unless explicitly transformed)\n    if ((value === null || value === '') && !config.transform) {\n      continue\n    }\n\n    // Apply transformation if provided\n    if (config.transform) {\n      value = config.transform(value)\n    }\n\n    // Convert value to string based on type\n    let stringValue: string\n    let paramType: 'SingleValue' | 'Xml' | 'ComplexObject' = config.type || 'SingleValue'\n\n    if (value instanceof File || (Array.isArray(value) && value.length > 0 && value[0] instanceof File)) {\n      // Skip file objects - files are handled separately\n      continue\n    } else if (Array.isArray(value)) {\n      stringValue = JSON.stringify(value)\n    } else if (value instanceof Date) {\n      stringValue = value.toISOString()\n    } else if (typeof value === 'object' && value !== null) {\n      stringValue = JSON.stringify(value)\n      if (!config.type) {\n        paramType = 'ComplexObject'\n      }\n    } else if (typeof value === 'boolean') {\n      stringValue = value.toString()\n    } else {\n      stringValue = String(value)\n    }\n\n    // Create parameter\n    parameters.push({\n      name: config.parameterName,\n      value: stringValue,\n      type: paramType,\n      direction: config.direction || 'In',\n    })\n  }\n\n  return parameters\n}\n","/**\n * Bizuit Form Service\n * High-level service for common form workflows\n *\n * Provides simplified methods that encapsulate common patterns:\n * - Starting new processes with form data + additional parameters\n * - Continuing existing processes with selective field mapping\n * - Managing locks automatically\n *\n * Use this service for common cases. For advanced control, use BizuitProcessService directly.\n */\n\nimport type { IParameter, IProcessResult } from '../types'\nimport {\n  buildParameters,\n  formDataToParameters,\n  createParameter,\n  loadInstanceDataForContinue,\n  releaseInstanceLock,\n  type IParameterMapping,\n  type ILockInfo,\n  type IBizuitProcessParameter,\n} from '../utils/form-utils'\n\nexport class BizuitFormService {\n  constructor(private sdk: any) {}\n\n  /**\n   * Prepares a form for STARTING a new process\n   *\n   * @returns Parameters ready to render the form\n   */\n  async prepareStartForm(options: {\n    processName: string\n    version?: string\n    token: string\n  }): Promise<{\n    parameters: IBizuitProcessParameter[]\n    formData: Record<string, any>\n  }> {\n    // Get process definition\n    const processData = await this.sdk.process.initialize({\n      processName: options.processName,\n      version: options.version,\n      token: options.token\n    })\n\n    // Filter parameters for start form\n    const parameters = processData.parameters || []\n\n    // Convert to formData (with default values)\n    const formData: Record<string, any> = {}\n    parameters.forEach((param: any) => {\n      if (param.value !== null && param.value !== undefined) {\n        formData[param.name] = param.value\n      }\n    })\n\n    return { parameters, formData }\n  }\n\n  /**\n   * Starts a new process combining:\n   * - Parameters mapped from form fields\n   * - Additional parameters (not associated with fields)\n   *\n   * @example\n   * ```typescript\n   * // Only form data (send all fields)\n   * await formService.startProcess({\n   *   processName: 'ExpenseRequest',\n   *   token,\n   *   formData: { empleado: 'Juan', monto: '5000' }\n   * })\n   *\n   * // Form data with selective mapping\n   * await formService.startProcess({\n   *   processName: 'ExpenseRequest',\n   *   token,\n   *   formData,\n   *   fieldMapping: {\n   *     'empleado': { parameterName: 'pEmpleado' },\n   *     'monto': {\n   *       parameterName: 'pMonto',\n   *       transform: (val) => parseFloat(val).toFixed(2)\n   *     }\n   *   }\n   * })\n   *\n   * // Form data + additional parameters\n   * await formService.startProcess({\n   *   processName: 'ExpenseRequest',\n   *   token,\n   *   formData,\n   *   fieldMapping,\n   *   additionalParameters: formService.createParameters([\n   *     { name: 'pUsuarioCreador', value: currentUser.username },\n   *     { name: 'pFechaCreacion', value: new Date().toISOString() }\n   *   ])\n   * })\n   * ```\n   */\n  async startProcess(options: {\n    processName: string\n    processVersion?: string\n    formData?: Record<string, any>\n    fieldMapping?: Record<string, IParameterMapping>\n    additionalParameters?: IParameter[]\n    files?: File[]\n    token: string\n  }): Promise<IProcessResult> {\n    const parameters: IParameter[] = []\n\n    // 1. Parameters from form fields (with selective mapping)\n    if (options.formData && options.fieldMapping) {\n      const mappedParams = buildParameters(options.fieldMapping, options.formData)\n      parameters.push(...mappedParams)\n    } else if (options.formData && !options.fieldMapping) {\n      // No mapping: send all fields\n      const allParams = formDataToParameters(options.formData)\n      parameters.push(...allParams)\n    }\n\n    // 2. Additional parameters (not associated with fields)\n    if (options.additionalParameters) {\n      parameters.push(...options.additionalParameters)\n    }\n\n    // 3. Start the process with all parameters\n    return await this.sdk.process.start({\n      processName: options.processName,\n      processVersion: options.processVersion,\n      parameters\n    }, options.files, options.token)\n  }\n\n  /**\n   * Prepares a form for CONTINUING an existing instance\n   *\n   * @returns Instance data ready to render and edit\n   */\n  async prepareContinueForm(options: {\n    instanceId: string\n    processName: string\n    activityName?: string\n    autoLock?: boolean\n    token: string\n  }): Promise<{\n    parameters: IBizuitProcessParameter[]\n    formData: Record<string, any>\n    lockInfo?: ILockInfo\n    instanceData: any\n  }> {\n    // Use existing helper (already does everything)\n    const result = await loadInstanceDataForContinue(\n      this.sdk,\n      {\n        instanceId: options.instanceId,\n        processName: options.processName,\n        activityName: options.activityName,\n        autoLock: options.autoLock\n      },\n      options.token\n    )\n\n    return {\n      parameters: result.formParameters,\n      formData: result.formData,\n      lockInfo: result.lockInfo,\n      instanceData: result.instanceData\n    }\n  }\n\n  /**\n   * Continues an existing process combining:\n   * - Parameters mapped from form fields\n   * - Additional parameters (not associated with fields)\n   *\n   * @example\n   * ```typescript\n   * // Form data + context parameters\n   * await formService.continueProcess({\n   *   instanceId: '123-456',\n   *   processName: 'ExpenseRequest',\n   *   token,\n   *   formData,\n   *   fieldMapping: {\n   *     'aprobado': {\n   *       parameterName: 'vAprobado',\n   *       isVariable: true\n   *     },\n   *     'comentarios': { parameterName: 'pComentarios' }\n   *   },\n   *   additionalParameters: formService.createParameters([\n   *     { name: 'vAprobador', value: currentUser.username },\n   *     { name: 'vFechaAprobacion', value: new Date().toISOString() }\n   *   ])\n   * })\n   * ```\n   */\n  async continueProcess(options: {\n    instanceId: string\n    processName: string\n    formData?: Record<string, any>\n    fieldMapping?: Record<string, IParameterMapping>\n    additionalParameters?: IParameter[]\n    files?: File[]\n    token: string\n  }): Promise<IProcessResult> {\n    const parameters: IParameter[] = []\n\n    // 1. Parameters from form fields\n    if (options.formData && options.fieldMapping) {\n      const mappedParams = buildParameters(options.fieldMapping, options.formData)\n      parameters.push(...mappedParams)\n    } else if (options.formData && !options.fieldMapping) {\n      const allParams = formDataToParameters(options.formData)\n      parameters.push(...allParams)\n    }\n\n    // 2. Additional parameters\n    if (options.additionalParameters) {\n      parameters.push(...options.additionalParameters)\n    }\n\n    // 3. Continue the process\n    return await this.sdk.process.continue({\n      processName: options.processName,\n      instanceId: options.instanceId,\n      parameters\n    }, options.files, options.token)\n  }\n\n  /**\n   * Releases a lock acquired during prepareContinueForm\n   */\n  async releaseLock(options: {\n    instanceId: string\n    activityName: string\n    sessionToken: string\n    token: string\n  }): Promise<void> {\n    return await releaseInstanceLock(\n      this.sdk,\n      {\n        instanceId: options.instanceId,\n        activityName: options.activityName,\n        sessionToken: options.sessionToken\n      },\n      options.token\n    )\n  }\n\n  /**\n   * Helper to create a single parameter easily\n   */\n  createParameter(\n    name: string,\n    value: any,\n    options?: {\n      type?: 'SingleValue' | 'Xml' | 'ComplexObject'\n      direction?: 'In' | 'Out' | 'InOut'\n    }\n  ): IParameter {\n    return createParameter(\n      name,\n      value,\n      options?.type || 'SingleValue',\n      options?.direction || 'In'\n    )\n  }\n\n  /**\n   * Helper to create multiple parameters easily\n   *\n   * @example\n   * ```typescript\n   * const params = formService.createParameters([\n   *   { name: 'pUsuario', value: currentUser.username },\n   *   { name: 'pFecha', value: new Date().toISOString() },\n   *   { name: 'pConfig', value: { theme: 'dark' }, type: 'ComplexObject' }\n   * ])\n   * ```\n   */\n  createParameters(params: Array<{\n    name: string\n    value: any\n    type?: 'SingleValue' | 'Xml' | 'ComplexObject'\n    direction?: 'In' | 'Out' | 'InOut'\n  }>): IParameter[] {\n    return params.map(p => this.createParameter(p.name, p.value, {\n      type: p.type,\n      direction: p.direction\n    }))\n  }\n}\n","/**\n * Bizuit SDK - Main entry point\n * Provides unified access to all Bizuit services\n */\n\nimport { BizuitAuthService } from './auth-service'\nimport { BizuitProcessService } from './process-service'\nimport { BizuitInstanceLockService } from './instance-lock-service'\nimport { BizuitFormService } from './form-service'\nimport type { IBizuitConfig } from '../types'\n\nexport class BizuitSDK {\n  public auth: BizuitAuthService\n  public process: BizuitProcessService\n  public instanceLock: BizuitInstanceLockService\n  public forms: BizuitFormService\n\n  private config: IBizuitConfig\n\n  constructor(config: IBizuitConfig) {\n    this.config = config\n    this.auth = new BizuitAuthService(config)\n    this.process = new BizuitProcessService(config)\n    this.instanceLock = new BizuitInstanceLockService(config)\n    this.forms = new BizuitFormService(this)\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): IBizuitConfig {\n    return { ...this.config }\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<IBizuitConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n\n    // Recreate services with new config\n    this.auth = new BizuitAuthService(this.config)\n    this.process = new BizuitProcessService(this.config)\n    this.instanceLock = new BizuitInstanceLockService(this.config)\n    this.forms = new BizuitFormService(this)\n  }\n}\n\n/**\n * Factory function to create SDK instance\n */\nexport function createBizuitSDK(config: IBizuitConfig): BizuitSDK {\n  return new BizuitSDK(config)\n}\n","/**\n * Parameter Parser Utilities\n * Handles complex parameter structures (JSON, XML, nested objects)\n */\n\nimport type { IParameter } from '../types'\n\nexport class ParameterParser {\n  /**\n   * Parse complex parameter value from JSON string\n   */\n  static parseComplexValue(parameter: IParameter): any {\n    if (!parameter.valueJson) {\n      return parameter.value\n    }\n\n    try {\n      return JSON.parse(parameter.valueJson)\n    } catch (error) {\n      console.warn('[ParameterParser] Failed to parse valueJson:', error)\n      return parameter.value\n    }\n  }\n\n  /**\n   * Serialize complex value to parameter format\n   */\n  static serializeComplexValue(value: any, type: 'SingleValue' | 'Xml' | 'ComplexObject'): { value: string; valueJson?: string } {\n    if (type === 'SingleValue') {\n      return {\n        value: String(value ?? ''),\n      }\n    }\n\n    if (typeof value === 'object') {\n      const jsonString = JSON.stringify(value)\n      return {\n        value: jsonString,\n        valueJson: jsonString,\n      }\n    }\n\n    return {\n      value: String(value ?? ''),\n      valueJson: String(value ?? ''),\n    }\n  }\n\n  /**\n   * Get value from nested path (e.g., \"customer.address.street\")\n   */\n  static getNestedValue(obj: any, path: string): any {\n    if (!path) return obj\n\n    const parts = path.split(/[./]/)\n    let current = obj\n\n    for (const part of parts) {\n      if (current === null || current === undefined) {\n        return undefined\n      }\n      current = current[part]\n    }\n\n    return current\n  }\n\n  /**\n   * Set value at nested path\n   */\n  static setNestedValue(obj: any, path: string, value: any): any {\n    if (!path) return value\n\n    const parts = path.split(/[./]/)\n    const last = parts.pop()!\n    let current = obj\n\n    for (const part of parts) {\n      if (!current[part]) {\n        current[part] = {}\n      }\n      current = current[part]\n    }\n\n    current[last] = value\n    return obj\n  }\n\n  /**\n   * Flatten parameters for form data\n   */\n  static flattenParameters(parameters: IParameter[]): Record<string, any> {\n    const flattened: Record<string, any> = {}\n\n    parameters.forEach((param) => {\n      if (param.type === 'SingleValue') {\n        flattened[param.name] = param.value\n      } else {\n        flattened[param.name] = this.parseComplexValue(param)\n      }\n    })\n\n    return flattened\n  }\n\n  /**\n   * Unflatten form data back to parameters\n   */\n  static unflattenToParameters(\n    data: Record<string, any>,\n    originalParameters: IParameter[]\n  ): IParameter[] {\n    return originalParameters.map((param) => {\n      const value = data[param.name]\n\n      if (value === undefined) {\n        return param\n      }\n\n      const serialized = this.serializeComplexValue(value, param.type)\n\n      return {\n        ...param,\n        ...serialized,\n      }\n    })\n  }\n\n  /**\n   * Merge parameters with form values\n   */\n  static mergeWithFormData(\n    parameters: IParameter[],\n    formData: Record<string, any>\n  ): IParameter[] {\n    return parameters.map((param) => {\n      if (formData.hasOwnProperty(param.name)) {\n        const serialized = this.serializeComplexValue(formData[param.name], param.type)\n        return {\n          ...param,\n          ...serialized,\n          hasBinding: true,\n        }\n      }\n      return param\n    })\n  }\n\n  /**\n   * Filter parameters by direction\n   */\n  static filterByDirection(\n    parameters: IParameter[],\n    direction: 'In' | 'Out' | 'InOut'\n  ): IParameter[] {\n    return parameters.filter((p) => p.direction === direction || p.direction === 'InOut')\n  }\n\n  /**\n   * Get input parameters only\n   */\n  static getInputParameters(parameters: IParameter[]): IParameter[] {\n    return this.filterByDirection(parameters, 'In')\n  }\n\n  /**\n   * Get output parameters only\n   */\n  static getOutputParameters(parameters: IParameter[]): IParameter[] {\n    return this.filterByDirection(parameters, 'Out')\n  }\n\n  /**\n   * Validate required parameters\n   */\n  static validateRequired(\n    parameters: IParameter[],\n    formData: Record<string, any>\n  ): { valid: boolean; missing: string[] } {\n    const inputParams = this.getInputParameters(parameters)\n    const missing: string[] = []\n\n    inputParams.forEach((param) => {\n      if (!param.isSystemParameter) {\n        const value = formData[param.name]\n        if (value === undefined || value === null || value === '') {\n          missing.push(param.name)\n        }\n      }\n    })\n\n    return {\n      valid: missing.length === 0,\n      missing,\n    }\n  }\n}\n","/**\n * Error Handler Utilities\n */\n\nimport type { IApiError } from '../types'\n\nexport class BizuitError extends Error {\n  code?: string\n  statusCode?: number\n  details?: unknown\n\n  constructor(message: string, code?: string, statusCode?: number, details?: unknown) {\n    super(message)\n    this.name = 'BizuitError'\n    this.code = code\n    this.statusCode = statusCode\n    this.details = details\n  }\n\n  static fromApiError(apiError: IApiError): BizuitError {\n    return new BizuitError(\n      apiError.message,\n      apiError.code,\n      apiError.statusCode,\n      apiError.details\n    )\n  }\n\n  isAuthError(): boolean {\n    return this.statusCode === 401 || this.code === 'UNAUTHORIZED'\n  }\n\n  isNetworkError(): boolean {\n    return this.code === 'NETWORK_ERROR'\n  }\n\n  isValidationError(): boolean {\n    return this.statusCode === 400 || this.code === 'VALIDATION_ERROR'\n  }\n}\n\nexport function handleError(error: unknown): BizuitError {\n  if (error instanceof BizuitError) {\n    return error\n  }\n\n  if (error instanceof Error) {\n    return new BizuitError(error.message)\n  }\n\n  if (typeof error === 'object' && error !== null) {\n    const apiError = error as IApiError\n    if (apiError.message) {\n      return BizuitError.fromApiError(apiError)\n    }\n  }\n\n  return new BizuitError('An unknown error occurred')\n}\n","import type { ILoginResponse } from '../types/auth.types'\n\n/**\n * Parse URL parameters that come from Bizuit BPM with &amp; HTML encoding\n *\n * When Bizuit generates URLs in HTML context, browsers URL-encode &amp; as &amp%3B\n * This breaks standard query parameter parsing since \"amp;\" becomes part of param name\n *\n * @param paramName - The parameter name to extract\n * @param searchParams - URLSearchParams object from useSearchParams()\n * @returns The parameter value or null if not found\n *\n * @example\n * ```tsx\n * const searchParams = useSearchParams()\n * const token = parseBizuitUrlParam('token', searchParams)\n * const eventName = parseBizuitUrlParam('eventName', searchParams)\n * ```\n */\nexport function parseBizuitUrlParam(paramName: string, searchParams: URLSearchParams): string | null {\n  // Try standard parsing first\n  const standardValue = searchParams.get(paramName)\n  if (standardValue) {\n    return standardValue\n  }\n\n  // If standard parsing fails, manually parse query string\n  // This handles cases where &amp; was URL-encoded to &amp%3B\n  if (typeof window !== 'undefined') {\n    const rawUrl = window.location.href\n\n    // Extract query string after ?\n    const queryStartIndex = rawUrl.indexOf('?')\n    if (queryStartIndex === -1) {\n      return null\n    }\n\n    let queryString = rawUrl.substring(queryStartIndex + 1)\n\n    // Clean up the query string:\n    // 1. Replace &amp%3B with & (URL-encoded &amp;)\n    // 2. Replace &amp; with & (HTML entity)\n    // 3. Replace %3B with nothing (leftover semicolons)\n    queryString = queryString\n      .replace(/&amp%3B/gi, '&')\n      .replace(/&amp;/gi, '&')\n      .replace(/%3B/gi, '')\n\n    // Parse manually\n    const params = new URLSearchParams(queryString)\n    return params.get(paramName)\n  }\n\n  return null\n}\n\n/**\n * Create an ILoginResponse object from a URL token\n *\n * This is useful when receiving authentication tokens from Bizuit BPM URLs.\n * The token will be prefixed with \"Basic \" if not already present.\n *\n * @param urlToken - The token from the URL (without \"Basic \" prefix)\n * @param userName - Optional username (defaults to 'bizuit-user')\n * @param expirationMinutes - Token expiration in minutes (defaults to 1440 = 24 hours)\n * @returns ILoginResponse object ready to use with setAuthData()\n *\n * @example\n * ```tsx\n * const urlToken = searchParams.get('token')\n * const userName = searchParams.get('UserName')\n *\n * if (urlToken) {\n *   const authData = createAuthFromUrlToken(urlToken, userName, 120) // 2 hours\n *   setAuthData(authData)\n * }\n * ```\n */\nexport function createAuthFromUrlToken(\n  urlToken: string,\n  userName?: string,\n  expirationMinutes: number = 1440\n): ILoginResponse {\n  // Add \"Basic \" prefix if not already present\n  const tokenWithPrefix = urlToken.startsWith('Basic ') ? urlToken : `Basic ${urlToken}`\n\n  const expirationMs = expirationMinutes * 60 * 1000\n\n  return {\n    Token: tokenWithPrefix,\n    User: {\n      Username: userName || 'bizuit-user',\n      UserID: 0,\n      DisplayName: userName || 'Usuario Bizuit',\n    },\n    ExpirationDate: new Date(Date.now() + expirationMs).toISOString(),\n  }\n}\n\n/**\n * Build a login redirect URL with return path\n *\n * @param returnPath - The path to redirect to after login (e.g., '/start-process')\n * @param params - Optional additional query parameters to include in the return URL\n * @returns Complete login URL with redirect parameter\n *\n * @example\n * ```tsx\n * // Simple redirect\n * const loginUrl = buildLoginRedirectUrl('/start-process')\n * // \"/login?redirect=%2Fstart-process\"\n *\n * // With additional parameters\n * const loginUrl = buildLoginRedirectUrl('/start-process', { eventName: 'MyEvent' })\n * // \"/login?redirect=%2Fstart-process%3FeventName%3DMyEvent\"\n * ```\n */\nexport function buildLoginRedirectUrl(returnPath: string, params?: Record<string, string>): string {\n  // Build return URL with optional parameters\n  let returnUrl = returnPath\n\n  if (params && Object.keys(params).length > 0) {\n    const queryParams = new URLSearchParams(params)\n    returnUrl = `${returnPath}?${queryParams.toString()}`\n  }\n\n  // Build login URL with redirect parameter\n  const loginParams = new URLSearchParams()\n  loginParams.set('redirect', returnUrl)\n\n  return `/login?${loginParams.toString()}`\n}\n","/**\n * Context type for error formatting\n */\nexport type ErrorContext = 'load' | 'submit' | 'lock' | 'start' | 'general'\n\n/**\n * Convert API errors to user-friendly messages\n *\n * Handles common HTTP status codes and network errors to provide\n * helpful feedback to users instead of technical error messages.\n *\n * @param error - The error object from API call\n * @param context - The context where the error occurred\n * @returns User-friendly error message in Spanish\n *\n * @example\n * ```tsx\n * try {\n *   await sdk.process.raiseEvent(...)\n * } catch (err) {\n *   const message = formatBizuitError(err, 'start')\n *   setError(message)\n * }\n * ```\n */\nexport function formatBizuitError(error: any, context: ErrorContext = 'general'): string {\n  // Check status code\n  const statusCode = error?.statusCode || error?.status || error?.response?.status\n\n  // 401 errors - Unauthorized\n  // Note: These should be handled automatically by useBizuitSDKWithAuth\n  if (statusCode === 401) {\n    return 'Su sesión ha expirado. Redirigiendo a login...'\n  }\n\n  // 404 errors - Not Found\n  if (statusCode === 404) {\n    if (context === 'load') {\n      return 'No se encontró la instancia del proceso. Verifique que el ID sea correcto.'\n    }\n    if (context === 'start') {\n      return 'El proceso no existe o no tiene parámetros definidos. Verifique el nombre del proceso.'\n    }\n    return 'No se encontró el recurso solicitado. Verifique los datos ingresados.'\n  }\n\n  // 400 errors - Bad Request (usually validation errors)\n  if (statusCode === 400) {\n    // Check for specific validation messages in error\n    const message = error?.message || error?.errorMessage || ''\n\n    if (message.toLowerCase().includes('format') || message.toLowerCase().includes('formato')) {\n      return 'El formato del ID de instancia es incorrecto. Debe ser un GUID válido (ejemplo: 550e8400-e29b-41d4-a716-446655440000).'\n    }\n\n    if (message.toLowerCase().includes('required') || message.toLowerCase().includes('requerido')) {\n      return 'Faltan datos requeridos. Verifique que todos los campos obligatorios estén completos.'\n    }\n\n    return 'Los datos enviados no son válidos. Verifique la información e intente nuevamente.'\n  }\n\n  // 403 errors - Forbidden\n  if (statusCode === 403) {\n    return 'No tiene permisos para realizar esta operación.'\n  }\n\n  // 409 errors - Conflict (instance locked by another user)\n  if (statusCode === 409) {\n    return 'La instancia está bloqueada por otro usuario. Intente nuevamente más tarde.'\n  }\n\n  // 500 errors - Server Error\n  if (statusCode === 500 || statusCode >= 500) {\n    return 'Error en el servidor. Por favor intente nuevamente o contacte al administrador.'\n  }\n\n  // Network errors\n  if (\n    error?.code === 'ECONNREFUSED' ||\n    error?.code === 'ERR_NETWORK' ||\n    error?.message?.includes('fetch failed') ||\n    error?.message?.includes('Network')\n  ) {\n    return 'No se pudo conectar al servidor. Verifique su conexión a internet.'\n  }\n\n  // Timeout errors\n  if (error?.code === 'ETIMEDOUT' || error?.message?.includes('timeout')) {\n    return 'La operación tardó demasiado tiempo. Verifique su conexión e intente nuevamente.'\n  }\n\n  // If we have a user-friendly message from the API, use it\n  if (error?.errorMessage && typeof error.errorMessage === 'string' && error.errorMessage.length < 200) {\n    return error.errorMessage\n  }\n\n  if (error?.message && typeof error.message === 'string' && error.message.length < 200) {\n    // Don't show very technical messages\n    if (\n      !error.message.includes('undefined') &&\n      !error.message.includes('null') &&\n      !error.message.includes('Cannot read') &&\n      !error.message.includes('is not')\n    ) {\n      return error.message\n    }\n  }\n\n  // Default messages by context\n  if (context === 'load') {\n    return 'Error al cargar los datos de la instancia. Por favor intente nuevamente.'\n  }\n  if (context === 'submit') {\n    return 'Error al guardar los cambios. Por favor intente nuevamente.'\n  }\n  if (context === 'lock') {\n    return 'Error al bloquear la instancia. Por favor intente nuevamente.'\n  }\n  if (context === 'start') {\n    return 'Error al iniciar el proceso. Por favor intente nuevamente.'\n  }\n\n  return 'Ocurrió un error inesperado. Por favor intente nuevamente.'\n}\n","/**\n * @bizuit/form-sdk/core\n * Core SDK without React dependencies - safe for server-side usage\n *\n * Use this entry point in:\n * - Next.js API routes\n * - Server components\n * - Node.js backends\n * - Any environment without React\n */\n\n// Types\nexport * from './lib/types'\n\n// API Services (no React dependencies)\nexport * from './lib/api'\n\n// Utilities (no React dependencies)\nexport * from './lib/utils'\n\n// Version\nexport const VERSION = '1.0.0'\n"],"mappings":"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","names":[]}