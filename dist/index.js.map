{"version":3,"sources":["../src/index.ts","../src/lib/api/http-client.ts","../src/lib/api/auth-service.ts","../src/lib/utils/xml-parser.ts","../src/lib/utils/xsd-parser.ts","../src/lib/models/xml-parameter.ts","../src/lib/api/process-service.ts","../src/lib/api/instance-lock-service.ts","../src/lib/utils/form-utils.ts","../src/lib/api/form-service.ts","../src/lib/api/dataservice-service.ts","../src/lib/api/task-service.ts","../src/lib/api/bizuit-sdk.ts","../src/lib/utils/parameter-parser.ts","../src/lib/utils/error-handler.ts","../src/lib/utils/auth-utils.ts","../src/lib/utils/error-formatter.ts","../src/lib/hooks/useBizuitSDK.tsx","../src/lib/hooks/useAuth.tsx","../src/lib/hooks/useTasks.tsx"],"sourcesContent":["/**\n * @bizuit/form-sdk\n * Core SDK for Bizuit BPM form integration\n *\n * IMPORTANT: This entry point exports React hooks.\n * For server-side usage (Next.js API routes, etc), use:\n * import { BizuitSDK } from '@tyconsa/bizuit-form-sdk/core'\n */\n\n// Types\nexport * from './lib/types'\n\n// API Services\nexport * from './lib/api'\n\n// Utilities\nexport * from './lib/utils'\n\n// Models\nexport * from './lib/models'\n\n// React Hooks (client-side only)\nexport * from './lib/hooks/useBizuitSDK.tsx'\nexport * from './lib/hooks/useAuth.tsx'\nexport * from './lib/hooks/useTasks.tsx'\n\n// Version\nexport const VERSION = '1.0.0'\n","/**\n * Bizuit HTTP Client\n * Axios-based client with interceptors for Bizuit API headers\n */\n\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosError } from 'axios'\nimport type { IBizuitConfig, IApiError, IBizuitAuthHeaders, IBizuitFile } from '../types'\n\nexport class BizuitHttpClient {\n  private axiosInstance: AxiosInstance\n  private config: IBizuitConfig\n\n  constructor(config: IBizuitConfig) {\n    this.config = config\n    this.axiosInstance = axios.create({\n      timeout: config.timeout || 120000, // 2 minutes default\n      headers: {\n        'Content-Type': 'application/json',\n        ...config.defaultHeaders,\n      },\n    })\n\n    this.setupInterceptors()\n  }\n\n  private setupInterceptors(): void {\n    // Request interceptor\n    this.axiosInstance.interceptors.request.use(\n      (config) => {\n        // Log requests in development\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[Bizuit API Request]', {\n            method: config.method?.toUpperCase(),\n            url: config.url,\n            headers: this.sanitizeHeaders(config.headers),\n          })\n        }\n        return config\n      },\n      (error) => {\n        return Promise.reject(this.handleError(error))\n      }\n    )\n\n    // Response interceptor\n    this.axiosInstance.interceptors.response.use(\n      (response) => {\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[Bizuit API Response]', {\n            status: response.status,\n            url: response.config.url,\n          })\n        }\n        return response\n      },\n      (error) => {\n        return Promise.reject(this.handleError(error))\n      }\n    )\n  }\n\n  private sanitizeHeaders(headers: any): Record<string, string> {\n    const sanitized: Record<string, string> = {}\n    for (const key in headers) {\n      // Hide sensitive tokens in logs\n      if (key.toLowerCase().includes('token') || key.toLowerCase().includes('auth')) {\n        sanitized[key] = '***REDACTED***'\n      } else {\n        sanitized[key] = headers[key]\n      }\n    }\n    return sanitized\n  }\n\n  private handleError(error: AxiosError): IApiError {\n    const apiError: IApiError = {\n      message: 'An unexpected error occurred',\n      statusCode: error.response?.status,\n    }\n\n    if (error.response) {\n      // Server responded with error status\n      const data = error.response.data as any\n      apiError.message = data?.message || data?.errorMessage || error.message\n      apiError.code = data?.errorType || data?.code\n      apiError.details = data\n    } else if (error.request) {\n      // Request made but no response\n      apiError.message = 'No response from server'\n      apiError.code = 'NETWORK_ERROR'\n    } else {\n      // Error in request setup\n      apiError.message = error.message\n      apiError.code = 'REQUEST_ERROR'\n    }\n\n    return apiError\n  }\n\n  /**\n   * GET request\n   */\n  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.get<T>(url, config)\n    return response.data\n  }\n\n  /**\n   * POST request\n   */\n  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.post<T>(url, data, config)\n    return response.data\n  }\n\n  /**\n   * PUT request\n   */\n  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.put<T>(url, data, config)\n    return response.data\n  }\n\n  /**\n   * PATCH request\n   */\n  async patch<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.patch<T>(url, data, config)\n    return response.data\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    const response = await this.axiosInstance.delete<T>(url, config)\n    return response.data\n  }\n\n  /**\n   * Convert IBizuitFile to File object\n   */\n  private convertToFile(bizuitFile: IBizuitFile): File {\n    const { fileName, content, mimeType, encoding } = bizuitFile\n\n    // If already a File, return as-is\n    if (content instanceof File) {\n      return content\n    }\n\n    // If Blob, create File from it\n    if (content instanceof Blob) {\n      return new File([content], fileName, { type: mimeType || content.type })\n    }\n\n    // If ArrayBuffer, create File from it\n    if (content instanceof ArrayBuffer) {\n      return new File([content], fileName, { type: mimeType || 'application/octet-stream' })\n    }\n\n    // If string (base64), decode and create File\n    if (typeof content === 'string') {\n      try {\n        // Remove data URL prefix if present (e.g., \"data:image/png;base64,\")\n        const base64String = content.includes(',') ? content.split(',')[1] : content\n\n        // Decode base64 to binary\n        const binaryString = atob(base64String)\n        const bytes = new Uint8Array(binaryString.length)\n        for (let i = 0; i < binaryString.length; i++) {\n          bytes[i] = binaryString.charCodeAt(i)\n        }\n\n        return new File([bytes], fileName, { type: mimeType || 'application/octet-stream' })\n      } catch (error) {\n        throw new Error(`Failed to decode base64 string for file ${fileName}: ${error}`)\n      }\n    }\n\n    throw new Error(`Unsupported content type for file ${fileName}`)\n  }\n\n  /**\n   * POST request with multipart/form-data for Dashboard API file uploads\n   * - Encodes JSON data as Base64 in 'data' field\n   * - Appends files with their actual filenames\n   * - Supports both File[] and IBizuitFile[] for flexible file sources\n   */\n  async postMultipart<T>(\n    url: string,\n    data: any,\n    files: File[] | IBizuitFile[],\n    config?: AxiosRequestConfig\n  ): Promise<T> {\n    const formData = new FormData()\n\n    // Base64 encode JSON data for Dashboard API\n    const jsonString = JSON.stringify(data)\n    const base64Data = btoa(jsonString)\n    formData.append('data', base64Data)\n\n    // Convert all files to File objects and add to FormData\n    const fileObjects = files.map((file) => {\n      if (file instanceof File) {\n        return file\n      }\n      return this.convertToFile(file as IBizuitFile)\n    })\n\n    fileObjects.forEach((file) => {\n      formData.append(file.name, file, file.name)\n    })\n\n    const requestConfig: AxiosRequestConfig = {\n      ...config,\n      headers: {\n        ...config?.headers,\n        'Content-Type': 'multipart/form-data',\n      },\n    }\n\n    const response = await this.axiosInstance.post<T>(url, formData, requestConfig)\n    return response.data\n  }\n\n  /**\n   * Add Bizuit-specific headers to request\n   */\n  withBizuitHeaders(headers: IBizuitAuthHeaders): BizuitHttpClient {\n    const cleanHeaders: Record<string, string> = {}\n\n    Object.entries(headers).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        cleanHeaders[key] = String(value)\n      }\n    })\n\n    this.axiosInstance.defaults.headers.common = {\n      ...this.axiosInstance.defaults.headers.common,\n      ...cleanHeaders,\n    }\n\n    return this\n  }\n\n  /**\n   * Clear all Bizuit headers\n   */\n  clearBizuitHeaders(): BizuitHttpClient {\n    const bizuitHeaderPrefixes = ['BZ-']\n    const headers = this.axiosInstance.defaults.headers.common\n\n    Object.keys(headers).forEach((key) => {\n      if (bizuitHeaderPrefixes.some((prefix) => key.startsWith(prefix))) {\n        delete headers[key]\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Get raw axios instance for advanced usage\n   */\n  getAxiosInstance(): AxiosInstance {\n    return this.axiosInstance\n  }\n}\n","/**\n * Bizuit Authentication Service\n * Handles token validation, user info, and auth checks\n */\n\nimport { BizuitHttpClient } from './http-client'\nimport type {\n  IAuthCheckResponse,\n  IUserInfo,\n  IRequestCheckFormAuth,\n  ILoginSettings,\n  IBizuitConfig,\n  ILoginRequest,\n  ILoginResponse,\n} from '../types'\n\nexport class BizuitAuthService {\n  private client: BizuitHttpClient\n  private apiUrl: string\n\n  constructor(config: IBizuitConfig) {\n    this.client = new BizuitHttpClient(config)\n    this.apiUrl = config.apiUrl\n  }\n\n  /**\n   * Check form authentication and authorization\n   * Validates token and returns login configuration\n   */\n  async checkFormAuth(\n    request: IRequestCheckFormAuth,\n    token?: string\n  ): Promise<IAuthCheckResponse> {\n    const headers: Record<string, string> = {\n      'BZ-FORM-VIEWER': 'true',\n    }\n\n    if (token) {\n      headers['BZ-AUTH-TOKEN'] = token\n    }\n\n    if (request.formId) {\n      headers['BZ-FORM-ID'] = String(request.formId)\n    }\n\n    if (request.formName) {\n      headers['BZ-FORM-NAME'] = request.formName\n    }\n\n    if (request.processName) {\n      headers['BZ-PROCESS-NAME'] = request.processName\n    }\n\n    try {\n      const response = await this.client.post<IAuthCheckResponse>(\n        `${this.apiUrl}/Login/CheckFormAuth`,\n        request,\n        { headers }\n      )\n\n      return response\n    } catch (error: any) {\n      return {\n        success: false,\n        canRetry: error.statusCode !== 401,\n        errorMessage: error.message,\n        errorType: error.code,\n      }\n    }\n  }\n\n  /**\n   * Get current user information from token\n   */\n  async getUserInfo(token: string, userName: string): Promise<IUserInfo> {\n    this.client.withBizuitHeaders({\n      'BZ-AUTH-TOKEN': token,\n      'BZ-USER-NAME': userName,\n    })\n\n    const userInfo = await this.client.get<IUserInfo>(\n      `${this.apiUrl}/Login/UserInfo`\n    )\n\n    this.client.clearBizuitHeaders()\n\n    return userInfo\n  }\n\n  /**\n   * Get login configuration (OAuth, AD, etc.)\n   */\n  async getLoginConfiguration(): Promise<Partial<ILoginSettings>> {\n    const config = await this.client.get<Partial<ILoginSettings>>(\n      `${this.apiUrl}/Login/LoginConfiguration`\n    )\n\n    return config\n  }\n\n  /**\n   * Validate token and get user data\n   * Returns null if token is invalid\n   */\n  async validateToken(token: string): Promise<IUserInfo | null> {\n    try {\n      // Extract username from token (Basic auth: base64(username:password))\n      const decoded = atob(token.replace('Basic ', ''))\n      const userName = decoded.split(':')[0]\n\n      const userInfo = await this.getUserInfo(token, userName)\n      return userInfo\n    } catch (error) {\n      console.error('[BizuitAuthService] Token validation failed:', error)\n      return null\n    }\n  }\n\n  /**\n   * Check if user has required permissions\n   */\n  async checkPermissions(\n    token: string,\n    userName: string,\n    requiredRoles: string[]\n  ): Promise<boolean> {\n    try {\n      const userInfo = await this.getUserInfo(token, userName)\n\n      if (!userInfo.roles || requiredRoles.length === 0) {\n        return true\n      }\n\n      return requiredRoles.some((role) => userInfo.roles.includes(role))\n    } catch (error) {\n      console.error('[BizuitAuthService] Permission check failed:', error)\n      return false\n    }\n  }\n\n  /**\n   * Login methods (delegated to Bizuit Dashboard API)\n   */\n  async azureLogin(idToken: string, accessToken: string): Promise<any> {\n    return this.client.post(`${this.apiUrl}/Login/AzureLogin`, {\n      idToken,\n      accessToken,\n    })\n  }\n\n  async oauthLogin(code: string, redirectUri: string): Promise<any> {\n    return this.client.get(\n      `${this.apiUrl}/Login/GetOauthLoginAsync?code=${code}&redirectUri=${redirectUri}`\n    )\n  }\n\n  async socialLogin(token: string, type: 'google' | 'facebook'): Promise<any> {\n    return this.client.get(`${this.apiUrl}/Login/SocialLogin?type=${type}`, {\n      headers: {\n        Authorization: `Basic ${token}`,\n      },\n    })\n  }\n\n  /**\n   * Login with username and password\n   * Uses HTTP Basic Authentication as per Bizuit API specification\n   * Returns token and user information\n   *\n   * Example response from API:\n   * {\n   *   \"token\": \"ZMdufWTdCsSYUXj7...\",\n   *   \"user\": {\n   *     \"username\": \"admin\",\n   *     \"userID\": 1,\n   *     \"displayName\": \"Administrator Account\",\n   *     \"image\": null\n   *   },\n   *   \"forceChange\": false,\n   *   \"expirationDate\": \"2025-11-27T22:07:20.5095101Z\"\n   * }\n   */\n  async login(credentials: ILoginRequest): Promise<ILoginResponse> {\n    const { username, password } = credentials\n\n    // Create Basic Auth header: base64(username:password)\n    const authString = `${username}:${password}`\n    const base64Auth = btoa(authString)\n    const authHeader = `Basic ${base64Auth}`\n\n    try {\n      // The API returns a JSON object with token and user info\n      const response = await this.client.get<any>(\n        `${this.apiUrl}/Login`,\n        {\n          headers: {\n            'Authorization': authHeader,\n          },\n        }\n      )\n\n      // Map the API response to our ILoginResponse format\n      const loginResponse: ILoginResponse = {\n        Token: `Basic ${response.token}`, // Prepend \"Basic \" to the token\n        User: {\n          Username: response.user.username,\n          UserID: response.user.userID,\n          DisplayName: response.user.displayName,\n          Image: response.user.image,\n        },\n        ForceChange: response.forceChange,\n        ExpirationDate: response.expirationDate,\n      }\n\n      return loginResponse\n    } catch (error: any) {\n      // Handle specific error messages from API\n      if (error.statusCode === 401) {\n        throw new Error('Nombre de Usuario y/o Contraseña incorrectos.')\n      } else if (error.statusCode === 403) {\n        throw new Error('Acceso denegado, no tiene permiso para acceder.')\n      }\n\n      throw error\n    }\n  }\n}\n","/**\n * XML to JSON Converter (bidirectional)\n * Automatically converts between XML strings and JavaScript objects\n * Used by process-service to parse/serialize XML parameters\n */\n\n/**\n * Converts a tag name to camelCase\n * Example: \"DatosPersonales\" -> \"datosPersonales\"\n * Example: \"ID\" -> \"id\"\n * Example: \"IDPersonal\" -> \"idPersonal\"\n */\nfunction toCamelCase(str: string): string {\n  if (!str) return str\n\n  // If the entire string is uppercase (like \"ID\"), convert to lowercase\n  if (str === str.toUpperCase()) {\n    return str.toLowerCase()\n  }\n\n  // If string starts with multiple uppercase letters (like \"IDPersonal\"),\n  // convert them to lowercase except the last one which starts the next word\n  // IDPersonal -> idPersonal\n  // IOError -> ioError\n  const match = str.match(/^([A-Z]+)([A-Z][a-z].*)$/)\n  if (match) {\n    return match[1].toLowerCase() + match[2]\n  }\n\n  // Default case: just lowercase the first character\n  return str.charAt(0).toLowerCase() + str.slice(1)\n}\n\n/**\n * Recursively converts an XML node to a JavaScript object\n * Handles:\n * - Text content\n * - Nested elements\n * - Multiple children with same tag name (converted to arrays)\n * - Converts tag names to camelCase\n */\nfunction xmlNodeToJson(node: Element): any {\n  const obj: any = {}\n\n  // Get all child elements (excluding text nodes, comments, etc.)\n  const children = Array.from(node.children)\n\n  // If no children, return text content\n  if (children.length === 0) {\n    const textContent = node.textContent?.trim() || ''\n    return textContent\n  }\n\n  // Group children by tag name\n  const childrenByTag = new Map<string, Element[]>()\n\n  children.forEach(child => {\n    const tagName = toCamelCase(child.tagName)\n    if (!childrenByTag.has(tagName)) {\n      childrenByTag.set(tagName, [])\n    }\n    childrenByTag.get(tagName)!.push(child)\n  })\n\n  // Convert each group to JSON\n  childrenByTag.forEach((elements, tagName) => {\n    if (elements.length === 1) {\n      // Single child - convert to object\n      obj[tagName] = xmlNodeToJson(elements[0])\n    } else {\n      // Multiple children with same name - convert to array\n      obj[tagName] = elements.map(el => xmlNodeToJson(el))\n    }\n  })\n\n  return obj\n}\n\n/**\n * Converts an XML string to a JavaScript object\n *\n * @param xmlString - The XML string to parse\n * @returns JavaScript object representation of the XML, or null on error\n *\n * @example\n * ```typescript\n * const xml = `\n *   <Deudor>\n *     <DatosPersonales>\n *       <ID>75</ID>\n *       <Nombre>John Doe</Nombre>\n *     </DatosPersonales>\n *     <Contactos>\n *       <Contacto><ID>1</ID></Contacto>\n *       <Contacto><ID>2</ID></Contacto>\n *     </Contactos>\n *   </Deudor>\n * `\n *\n * const result = xmlToJson(xml)\n * // {\n * //   deudor: {\n * //     datosPersonales: {\n * //       id: \"75\",\n * //       nombre: \"John Doe\"\n * //     },\n * //     contactos: {\n * //       contacto: [\n * //         { id: \"1\" },\n * //         { id: \"2\" }\n * //       ]\n * //     }\n * //   }\n * // }\n * ```\n */\nexport function xmlToJson(xmlString: string): any | null {\n  try {\n    // Parse XML string\n    const parser = new DOMParser()\n    const xmlDoc = parser.parseFromString(xmlString, 'text/xml')\n\n    // Check for parsing errors\n    const parserError = xmlDoc.querySelector('parsererror')\n    if (parserError) {\n      console.error('XML parsing error:', parserError.textContent)\n      return null\n    }\n\n    // Get root element\n    const rootElement = xmlDoc.documentElement\n    if (!rootElement) {\n      console.error('No root element found in XML')\n      return null\n    }\n\n    // Convert root element to JSON\n    const rootTagName = toCamelCase(rootElement.tagName)\n    const result = {\n      [rootTagName]: xmlNodeToJson(rootElement)\n    }\n\n    return result\n  } catch (error) {\n    console.error('Error converting XML to JSON:', error)\n    return null\n  }\n}\n\n/**\n * Converts a JavaScript object to an XML string\n * This is the inverse operation of xmlToJson()\n *\n * @param obj - The JavaScript object to convert\n * @param options - Conversion options\n * @returns XML string representation of the object\n *\n * @example\n * ```typescript\n * const obj = {\n *   raiz: {\n *     nombre: \"Test\",\n *     productos: {\n *       producto: [\n *         { codigo: \"PROD001\", descripcion: \"Producto 1\" },\n *         { codigo: \"PROD002\", descripcion: \"Producto 2\" }\n *       ]\n *     }\n *   }\n * }\n *\n * const xml = jsonToXml(obj)\n * // <raiz>\n * //   <nombre>Test</nombre>\n * //   <productos>\n * //     <producto>\n * //       <codigo>PROD001</codigo>\n * //       <descripcion>Producto 1</descripcion>\n * //     </producto>\n * //     <producto>\n * //       <codigo>PROD002</codigo>\n * //       <descripcion>Producto 2</descripcion>\n * //     </producto>\n * //   </productos>\n * // </raiz>\n * ```\n */\nexport function jsonToXml(\n  obj: any,\n  options: { indent?: number; currentIndent?: number } = {}\n): string {\n  const { indent = 2, currentIndent = 0 } = options\n\n  try {\n    // Handle null/undefined\n    if (obj === null || obj === undefined) {\n      return ''\n    }\n\n    // Handle primitive values\n    if (typeof obj !== 'object') {\n      return String(obj)\n    }\n\n    // Get the root key\n    const keys = Object.keys(obj)\n    if (keys.length === 0) {\n      return ''\n    }\n\n    const rootKey = keys[0]\n    const rootValue = obj[rootKey]\n\n    // Build XML recursively\n    return buildXmlNode(rootKey, rootValue, indent, currentIndent)\n  } catch (error) {\n    console.error('Error converting JSON to XML:', error)\n    return ''\n  }\n}\n\n/**\n * Recursively builds an XML node from a JavaScript value\n */\nfunction buildXmlNode(\n  tagName: string,\n  value: any,\n  indent: number,\n  currentIndent: number\n): string {\n  const indentStr = ' '.repeat(currentIndent)\n  const childIndentStr = ' '.repeat(currentIndent + indent)\n\n  // Handle null/undefined\n  if (value === null || value === undefined) {\n    return `${indentStr}<${tagName}></${tagName}>`\n  }\n\n  // Handle primitive values (string, number, boolean)\n  if (typeof value !== 'object') {\n    return `${indentStr}<${tagName}>${escapeXml(String(value))}</${tagName}>`\n  }\n\n  // Handle arrays\n  if (Array.isArray(value)) {\n    // For arrays, each item gets the same tag name\n    return value\n      .map(item => buildXmlNode(tagName, item, indent, currentIndent))\n      .join('\\n')\n  }\n\n  // Handle objects\n  const childKeys = Object.keys(value)\n\n  if (childKeys.length === 0) {\n    return `${indentStr}<${tagName}></${tagName}>`\n  }\n\n  const childNodes = childKeys\n    .map(key => {\n      const childValue = value[key]\n      return buildXmlNode(key, childValue, indent, currentIndent + indent)\n    })\n    .join('\\n')\n\n  return `${indentStr}<${tagName}>\\n${childNodes}\\n${indentStr}</${tagName}>`\n}\n\n/**\n * Escapes special XML characters\n */\nfunction escapeXml(str: string): string {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&apos;')\n}\n","/**\n * XSD Schema Parser\n *\n * Parses XSD (XML Schema Definition) and generates JavaScript object templates\n * for use with XmlParameter class.\n *\n * @example\n * ```typescript\n * const xsd = `\n *   <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n *     <xs:element name=\"deudor\">\n *       <xs:complexType>\n *         <xs:sequence>\n *           <xs:element name=\"id\" type=\"xs:integer\"/>\n *           <xs:element name=\"nombre\" type=\"xs:string\"/>\n *         </xs:sequence>\n *       </xs:complexType>\n *     </xs:element>\n *   </xs:schema>\n * `\n *\n * const template = parseXsdToTemplate(xsd)\n * // Result: { deudor: { id: null, nombre: null } }\n * ```\n */\n\n/**\n * Parses an XSD schema string and generates a JavaScript object template\n *\n * @param xsdString - XSD schema as string\n * @returns JavaScript object template representing the schema structure\n */\nexport function parseXsdToTemplate(xsdString: string): any {\n  if (!xsdString || typeof xsdString !== 'string') {\n    console.warn('Invalid XSD string provided')\n    return {}\n  }\n\n  try {\n    // Parse XML\n    const parser = new DOMParser()\n    const xmlDoc = parser.parseFromString(xsdString, 'text/xml')\n\n    // Check for parsing errors\n    const parserError = xmlDoc.querySelector('parsererror')\n    if (parserError) {\n      console.error('XSD parsing error:', parserError.textContent)\n      return {}\n    }\n\n    // Find root element definition\n    const rootElement = xmlDoc.querySelector('schema > element, xs\\\\:schema > xs\\\\:element')\n    if (!rootElement) {\n      console.warn('No root element found in XSD')\n      return {}\n    }\n\n    // Parse the root element\n    const rootName = rootElement.getAttribute('name')\n    if (!rootName) {\n      console.warn('Root element has no name')\n      return {}\n    }\n\n    const rootValue = parseElement(rootElement, xmlDoc)\n\n    return { [rootName]: rootValue }\n  } catch (error) {\n    console.error('Error parsing XSD:', error)\n    return {}\n  }\n}\n\n/**\n * Parses an xs:element node\n */\nfunction parseElement(element: Element, xmlDoc: Document): any {\n  const elementType = element.getAttribute('type')\n  const minOccurs = element.getAttribute('minOccurs')\n  const maxOccurs = element.getAttribute('maxOccurs')\n\n  // Check if it's an array (maxOccurs > 1 or unbounded)\n  const isArray = maxOccurs === 'unbounded' || (maxOccurs && parseInt(maxOccurs, 10) > 1)\n\n  // If element has inline complexType\n  const complexType = element.querySelector(':scope > complexType, :scope > xs\\\\:complexType')\n  if (complexType) {\n    const value = parseComplexType(complexType, xmlDoc)\n    return isArray ? [value] : value\n  }\n\n  // If element references a type\n  if (elementType) {\n    const value = parseType(elementType, xmlDoc)\n    return isArray ? [value] : value\n  }\n\n  // Simple element with no type (default to null)\n  return isArray ? [] : null\n}\n\n/**\n * Parses an xs:complexType node\n */\nfunction parseComplexType(complexType: Element, xmlDoc: Document): any {\n  const result: any = {}\n\n  // Handle xs:sequence\n  const sequence = complexType.querySelector(':scope > sequence, :scope > xs\\\\:sequence')\n  if (sequence) {\n    const elements = sequence.querySelectorAll(':scope > element, :scope > xs\\\\:element')\n    elements.forEach(el => {\n      const name = el.getAttribute('name')\n      if (name) {\n        result[name] = parseElement(el, xmlDoc)\n      }\n    })\n    return result\n  }\n\n  // Handle xs:all\n  const all = complexType.querySelector(':scope > all, :scope > xs\\\\:all')\n  if (all) {\n    const elements = all.querySelectorAll(':scope > element, :scope > xs\\\\:element')\n    elements.forEach(el => {\n      const name = el.getAttribute('name')\n      if (name) {\n        result[name] = parseElement(el, xmlDoc)\n      }\n    })\n    return result\n  }\n\n  // Handle xs:choice (pick first option as default)\n  const choice = complexType.querySelector(':scope > choice, :scope > xs\\\\:choice')\n  if (choice) {\n    const firstElement = choice.querySelector(':scope > element, :scope > xs\\\\:element')\n    if (firstElement) {\n      const name = firstElement.getAttribute('name')\n      if (name) {\n        result[name] = parseElement(firstElement, xmlDoc)\n      }\n    }\n    return result\n  }\n\n  return result\n}\n\n/**\n * Parses a type reference (xs:string, xs:integer, custom types, etc.)\n */\nfunction parseType(typeName: string, xmlDoc: Document): any {\n  // Handle built-in XML Schema types\n  const builtInTypes: Record<string, any> = {\n    'xs:string': null,\n    'xs:integer': null,\n    'xs:int': null,\n    'xs:long': null,\n    'xs:short': null,\n    'xs:byte': null,\n    'xs:decimal': null,\n    'xs:float': null,\n    'xs:double': null,\n    'xs:boolean': null,\n    'xs:date': null,\n    'xs:time': null,\n    'xs:dateTime': null,\n    'string': null,\n    'integer': null,\n    'int': null,\n    'long': null,\n    'short': null,\n    'byte': null,\n    'decimal': null,\n    'float': null,\n    'double': null,\n    'boolean': null,\n    'date': null,\n    'time': null,\n    'dateTime': null\n  }\n\n  // Check if it's a built-in type\n  if (typeName in builtInTypes) {\n    return builtInTypes[typeName]\n  }\n\n  // Look for custom type definition\n  const typeDefinition = xmlDoc.querySelector(\n    `complexType[name=\"${typeName}\"], xs\\\\:complexType[name=\"${typeName}\"]`\n  )\n\n  if (typeDefinition) {\n    return parseComplexType(typeDefinition, xmlDoc)\n  }\n\n  // Default: return null for unknown types\n  return null\n}\n\n/**\n * Simplified XSD parser for common use cases\n *\n * This is a basic implementation that handles:\n * - Simple elements with built-in types\n * - Complex types with sequences\n * - Arrays (maxOccurs > 1 or unbounded)\n * - Nested structures\n *\n * Limitations:\n * - Does not handle XML attributes\n * - Does not handle xs:restriction, xs:extension\n * - Does not handle xs:union, xs:list\n * - Does not handle recursive types\n * - Does not validate against the schema\n *\n * For advanced schema parsing, consider using a dedicated XSD parser library.\n */\n","/**\n * XmlParameter - Wrapper class for XML parameters with Proxy-based property access\n *\n * Allows developers to work with XML parameters as mutable JavaScript objects:\n *\n * @example\n * ```typescript\n * const params = await sdk.process.getParametersAsObjects('MyProcess', '', token)\n *\n * // Direct property modification (thanks to Proxy)\n * params.pSampleXml.nodo1 = 'a'\n * params.pSampleXml.productos[0].codigo = 'ABC'\n *\n * // Send directly to process\n * await sdk.process.start({\n *   processName: 'MyProcess',\n *   parameters: [params.pSampleXml]  // SDK auto-detects XmlParameter\n * }, [], token)\n * ```\n */\n\nimport type { IParameter } from '../types'\n\nexport class XmlParameter {\n  /**\n   * Symbol used to identify XmlParameter instances\n   * Used by ProcessService for auto-detection\n   */\n  static readonly TYPE_SYMBOL = Symbol('BizuitXmlParameter')\n\n  private _name: string\n  private _data: any\n  private _type: 'Xml' = 'Xml'\n  private _direction: 'In' | 'Out' | 'InOut'\n  private _originalTemplate: any\n\n  /**\n   * Creates a new XmlParameter instance\n   *\n   * @param name - Parameter name (e.g., 'pSampleXml')\n   * @param template - Object template representing the XML structure\n   * @param direction - Parameter direction (default: 'In')\n   *\n   * @example\n   * ```typescript\n   * const param = new XmlParameter('pDeudor', {\n   *   deudor: {\n   *     datosPersonales: {\n   *       id: null,\n   *       nombre: null\n   *     },\n   *     contactos: {\n   *       contacto: []\n   *     }\n   *   }\n   * }, 'In')\n   *\n   * // Direct property access via Proxy\n   * param.deudor.datosPersonales.nombre = 'Juan Perez'\n   * ```\n   */\n  constructor(name: string, template: any, direction: 'In' | 'Out' | 'InOut' = 'In') {\n    this._name = name\n    this._data = this._deepClone(template)\n    this._direction = direction\n    this._originalTemplate = this._deepClone(template)\n\n    // Mark instance as XmlParameter for auto-detection\n    ;(this as any)[XmlParameter.TYPE_SYMBOL] = true\n\n    // Return Proxy for transparent property access\n    return new Proxy(this, {\n      get(target, prop) {\n        // If accessing internal properties, return them\n        if (prop in target) {\n          return target[prop as keyof typeof target]\n        }\n\n        // Otherwise, access data properties\n        if (prop in target._data) {\n          return target._data[prop]\n        }\n\n        return undefined\n      },\n      set(target, prop, value) {\n        // Allow setting private properties (for internal methods like reset())\n        if (typeof prop === 'string' && prop.startsWith('_')) {\n          ;(target as any)[prop] = value\n          return true\n        }\n\n        // Don't allow setting other internal properties\n        if (prop in target) {\n          return false\n        }\n\n        // Set data properties\n        if (typeof prop === 'string') {\n          target._data[prop] = value\n          return true\n        }\n        return false\n      },\n      has(target, prop) {\n        return prop in target || prop in target._data\n      },\n      ownKeys(target) {\n        return [...Reflect.ownKeys(target), ...Object.keys(target._data)]\n      },\n      getOwnPropertyDescriptor(target, prop) {\n        if (prop in target._data) {\n          return {\n            enumerable: true,\n            configurable: true,\n            value: target._data[prop]\n          }\n        }\n        return Reflect.getOwnPropertyDescriptor(target, prop)\n      }\n    })\n  }\n\n  /**\n   * Converts XmlParameter to IParameter format for ProcessService\n   *\n   * @returns IParameter object ready to send to Bizuit API\n   */\n  toParameter(): IParameter {\n    return {\n      name: this._name,\n      value: this._data,\n      type: this._type,\n      direction: this._direction\n    }\n  }\n\n  /**\n   * Gets the parameter name\n   */\n  getName(): string {\n    return this._name\n  }\n\n  /**\n   * Gets the raw data object\n   */\n  getData(): any {\n    return this._data\n  }\n\n  /**\n   * Gets the parameter direction\n   */\n  getDirection(): 'In' | 'Out' | 'InOut' {\n    return this._direction\n  }\n\n  /**\n   * Resets the parameter data to the original template\n   */\n  reset(): void {\n    this._data = this._deepClone(this._originalTemplate)\n  }\n\n  /**\n   * Creates a deep clone of the XmlParameter\n   *\n   * @returns New XmlParameter instance with cloned data\n   */\n  clone(): XmlParameter {\n    return new XmlParameter(this._name, this._deepClone(this._data), this._direction)\n  }\n\n  /**\n   * Converts the parameter data to JSON string\n   */\n  toJSON(): string {\n    return JSON.stringify(this._data, null, 2)\n  }\n\n  /**\n   * Merges data from another object into this XmlParameter\n   *\n   * @param data - Object or XmlParameter to merge\n   * @param deep - Deep merge (default: true)\n   *\n   * @example\n   * ```typescript\n   * const param = new XmlParameter('pData', { raiz: { nombre: null, edad: null } })\n   * param.merge({ raiz: { nombre: 'Juan' } })\n   * // Result: { raiz: { nombre: 'Juan', edad: null } }\n   * ```\n   */\n  merge(data: any | XmlParameter, deep: boolean = true): void {\n    const sourceData = XmlParameter.isXmlParameter(data) ? data.getData() : data\n\n    if (deep) {\n      this._data = this._deepMerge(this._data, sourceData)\n    } else {\n      this._data = { ...this._data, ...sourceData }\n    }\n  }\n\n  /**\n   * Validates that all required fields have values (not null/undefined)\n   *\n   * @param schema - Optional schema object defining required fields\n   * @returns Array of missing field paths\n   *\n   * @example\n   * ```typescript\n   * const param = new XmlParameter('pData', { raiz: { nombre: null, edad: 30 } })\n   * param.raiz.nombre = 'Juan'\n   * const missing = param.validate()\n   * // Returns: [] (all fields filled)\n   *\n   * param.raiz.nombre = null\n   * const missing2 = param.validate()\n   * // Returns: ['raiz.nombre'] (missing field)\n   * ```\n   */\n  validate(schema?: any): string[] {\n    const missingFields: string[] = []\n\n    const checkObject = (obj: any, path: string = '') => {\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          const value = obj[key]\n          const currentPath = path ? `${path}.${key}` : key\n\n          if (value === null || value === undefined) {\n            missingFields.push(currentPath)\n          } else if (typeof value === 'object' && !Array.isArray(value)) {\n            checkObject(value, currentPath)\n          } else if (Array.isArray(value) && value.length === 0) {\n            missingFields.push(currentPath)\n          }\n        }\n      }\n    }\n\n    checkObject(this._data)\n    return missingFields\n  }\n\n  /**\n   * Fills the parameter with data from a source object\n   * Useful for mapping form data to parameter structure\n   *\n   * @param source - Source data object\n   * @param mapping - Optional field mapping { sourceField: targetPath }\n   *\n   * @example\n   * ```typescript\n   * const param = new XmlParameter('pDeudor', {\n   *   Deudor: { ID: null, Nombre: null, Contactos: { Contacto: [] } }\n   * })\n   *\n   * param.fillFrom(\n   *   { id: 123, nombre: 'Juan', email: 'juan@example.com' },\n   *   {\n   *     id: 'Deudor.ID',\n   *     nombre: 'Deudor.Nombre',\n   *     email: 'Deudor.Contactos.Contacto[0].Valor'\n   *   }\n   * )\n   * ```\n   */\n  fillFrom(source: any, mapping?: Record<string, string>): void {\n    if (!mapping) {\n      // Direct fill without mapping\n      this._data = this._deepClone(source)\n      return\n    }\n\n    // Fill with mapping\n    for (const sourceKey in mapping) {\n      if (Object.prototype.hasOwnProperty.call(source, sourceKey)) {\n        const targetPath = mapping[sourceKey]\n        const value = source[sourceKey]\n        this._setByPath(targetPath, value)\n      }\n    }\n  }\n\n  /**\n   * Gets a value by path (dot notation)\n   *\n   * @param path - Path in dot notation (e.g., 'raiz.productos.producto[0].codigo')\n   * @returns Value at path or undefined\n   */\n  getByPath(path: string): any {\n    return this._getByPath(this._data, path)\n  }\n\n  /**\n   * Sets a value by path (dot notation)\n   *\n   * @param path - Path in dot notation\n   * @param value - Value to set\n   */\n  setByPath(path: string, value: any): void {\n    this._setByPath(path, value)\n  }\n\n  /**\n   * Deep clone helper\n   */\n  private _deepClone(obj: any): any {\n    if (obj === null || typeof obj !== 'object') {\n      return obj\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(item => this._deepClone(item))\n    }\n\n    const cloned: any = {}\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        cloned[key] = this._deepClone(obj[key])\n      }\n    }\n    return cloned\n  }\n\n  /**\n   * Deep merge helper\n   */\n  private _deepMerge(target: any, source: any): any {\n    if (source === null || source === undefined) {\n      return target\n    }\n\n    if (typeof source !== 'object' || Array.isArray(source)) {\n      return source\n    }\n\n    const result = this._deepClone(target)\n\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n          result[key] = this._deepMerge(result[key] || {}, source[key])\n        } else {\n          result[key] = source[key]\n        }\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Get value by path helper\n   */\n  private _getByPath(obj: any, path: string): any {\n    const parts = path.replace(/\\[(\\d+)\\]/g, '.$1').split('.')\n    let current = obj\n\n    for (const part of parts) {\n      if (current === null || current === undefined) {\n        return undefined\n      }\n      current = current[part]\n    }\n\n    return current\n  }\n\n  /**\n   * Set value by path helper\n   */\n  private _setByPath(path: string, value: any): void {\n    const parts = path.replace(/\\[(\\d+)\\]/g, '.$1').split('.')\n    let current = this._data\n\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      const nextPart = parts[i + 1]\n\n      if (!(part in current)) {\n        // Create object or array based on next part\n        current[part] = /^\\d+$/.test(nextPart) ? [] : {}\n      }\n\n      current = current[part]\n    }\n\n    const lastPart = parts[parts.length - 1]\n    current[lastPart] = value\n  }\n\n  /**\n   * Static helper to check if an object is an XmlParameter instance\n   *\n   * @param obj - Object to check\n   * @returns true if obj is an XmlParameter instance\n   */\n  static isXmlParameter(obj: any): obj is XmlParameter {\n    if (!obj || typeof obj !== 'object') {\n      return false\n    }\n    return XmlParameter.TYPE_SYMBOL in obj\n  }\n}\n\n/**\n * Type guard for XmlParameter\n */\nexport function isXmlParameter(obj: any): obj is XmlParameter {\n  return XmlParameter.isXmlParameter(obj)\n}\n","/**\n * Bizuit Process Service\n * Handles process initialization, start and continue operations\n * Updated to match Bizuit API specification exactly\n */\n\nimport { BizuitHttpClient } from './http-client'\nimport type {\n  IBizuitConfig,\n  IInitializeParams,\n  IProcessData,\n  IStartProcessParams,\n  IProcessResult,\n  IBizuitFile,\n} from '../types'\nimport { xmlToJson, jsonToXml } from '../utils/xml-parser'\nimport { parseXsdToTemplate } from '../utils/xsd-parser'\nimport { XmlParameter } from '../models/xml-parameter'\n\nexport class BizuitProcessService {\n  private client: BizuitHttpClient\n  private apiUrl: string\n\n  constructor(config: IBizuitConfig) {\n    this.client = new BizuitHttpClient(config)\n    this.apiUrl = config.apiUrl\n  }\n\n  /**\n   * Initialize process - Get parameters for new or existing instance\n   * Uses standard Authorization header as per API specification\n   */\n  async initialize(params: IInitializeParams): Promise<IProcessData> {\n    const queryParams = new URLSearchParams()\n    queryParams.append('processName', params.processName)\n\n    if (params.activityName) queryParams.append('activityName', params.activityName)\n    if (params.version) queryParams.append('version', params.version)\n    if (params.instanceId) queryParams.append('instanceId', params.instanceId)\n\n    const headers: Record<string, string> = {}\n\n    // Use standard Authorization header with token\n    if (params.token) {\n      headers['Authorization'] = params.token\n    }\n\n    if (params.sessionToken) {\n      headers['BZ-SESSION-TOKEN'] = params.sessionToken\n    }\n\n    if (params.userName) {\n      headers['BZ-USER-NAME'] = params.userName\n    }\n\n    if (params.formId) {\n      headers['BZ-FORM'] = String(params.formId)\n    }\n\n    if (params.formDraftId) {\n      headers['BZ-DRAFT-FORM'] = String(params.formDraftId)\n    }\n\n    if (params.processName) {\n      headers['BZ-PROCESS-NAME'] = params.processName\n    }\n\n    if (params.instanceId) {\n      headers['BZ-INSTANCEID'] = params.instanceId\n    }\n\n    if (params.childProcessName) {\n      headers['BZ-CHILD-PROCESS-NAME'] = params.childProcessName\n    }\n\n    const processData = await this.client.get<IProcessData>(\n      `${this.apiUrl}/Process/Initialize?${queryParams.toString()}`,\n      { headers }\n    )\n\n    return processData\n  }\n\n  /**\n   * Start process - Execute process or start new instance\n   * Sends JSON directly as per Bizuit API specification\n   *\n   * Example from curl:\n   * POST /api/instances\n   * Authorization: Basic TOKEN\n   * Content-Type: application/json\n   * {\n   *   \"eventName\": \"DemoFlow\",\n   *   \"parameters\": [\n   *     {\n   *       \"name\": \"pData\",\n   *       \"value\": \"A\",\n   *       \"type\": \"SingleValue\",\n   *       \"direction\": \"In\"\n   *     }\n   *   ]\n   * }\n   */\n  async start(\n    params: IStartProcessParams,\n    files?: File[] | IBizuitFile[],\n    token?: string\n  ): Promise<IProcessResult> {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    }\n\n    // Use standard Authorization header with token\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    // Process parameters: handle XmlParameter instances and object-to-XML conversion\n    const processedParameters = (params.parameters || []).map(param => {\n      // Check if parameter is an XmlParameter instance\n      if (XmlParameter.isXmlParameter(param)) {\n        // Convert XmlParameter to IParameter and then to XML\n        const iParam = (param as XmlParameter).toParameter()\n        const xmlString = jsonToXml(iParam.value)\n        console.log(`✅ Auto-converted XmlParameter \"${iParam.name}\" to XML`)\n        return {\n          ...iParam,\n          value: xmlString\n        }\n      }\n\n      // Existing behavior: convert plain objects to XML\n      if (param.type === 'Xml' && typeof param.value === 'object' && param.value !== null) {\n        // Auto-convert JavaScript object to XML string\n        const xmlString = jsonToXml(param.value)\n        console.log(`✅ Auto-converted parameter \"${param.name}\" from object to XML`)\n        return {\n          ...param,\n          value: xmlString\n        }\n      }\n      return param\n    })\n\n    // Build the payload exactly as the API expects\n    const payload: any = {\n      eventName: params.processName,\n      parameters: processedParameters,\n    }\n\n    // Add optional fields only if provided\n    if (params.instanceId) {\n      payload.instanceId = params.instanceId\n    }\n\n    if (params.processVersion) {\n      payload.eventVersion = params.processVersion\n    }\n\n    if (params.closeOnSuccess !== undefined) {\n      payload.closeOnSuccess = params.closeOnSuccess\n    }\n\n    if (params.deletedDocuments && params.deletedDocuments.length > 0) {\n      payload.deletedDocuments = params.deletedDocuments\n    }\n\n    // Determine which files to use: from params or from files parameter\n    const filesToUpload = params.files || files\n\n    let result: IProcessResult\n\n    // Use multipart/form-data when files are present\n    if (filesToUpload && filesToUpload.length > 0) {\n      // Dashboard API: POST /api/instances/RaiseEvent with multipart\n      result = await this.client.postMultipart<IProcessResult>(\n        `${this.apiUrl}/instances/RaiseEvent`,\n        payload,\n        filesToUpload,\n        { headers: { 'BZ-AUTH-TOKEN': token } }\n      )\n    } else {\n      // Standard JSON request (existing behavior - no changes)\n      result = await this.client.post<IProcessResult>(\n        `${this.apiUrl}/instances`,\n        payload,\n        { headers }\n      )\n    }\n\n    // Automatically parse XML parameters to JSON\n    // Note: API returns tyconParameters, but we map it to parameters\n    const parametersArray = (result as any).tyconParameters || result.parameters;\n    if (parametersArray && Array.isArray(parametersArray)) {\n      parametersArray.forEach((param: any) => {\n        // Check if parameter type is 2 or \"Xml\" (XML/Complex) and has a value\n        if ((param.parameterType === 2 || param.parameterType === 'Xml') && param.value) {\n          try {\n            const parsedJson = xmlToJson(param.value)\n            if (parsedJson !== null) {\n              // Replace XML string with parsed JSON object\n              param.value = parsedJson as any\n              // Change parameterType to indicate it's now JSON\n              param.parameterType = 'Json' as any\n              console.log(`✅ Auto-parsed XML parameter: ${param.name}`)\n            } else {\n              console.warn(`⚠️ Failed to parse XML parameter: ${param.name}, keeping original XML`)\n            }\n          } catch (error) {\n            console.warn(`⚠️ Error parsing XML parameter ${param.name}:`, error)\n            // Keep original XML value on error\n          }\n        }\n      })\n\n      // Map tyconParameters to parameters for compatibility\n      if ((result as any).tyconParameters) {\n        result.parameters = parametersArray;\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Get process parameters schema\n   * Useful for dynamic form generation\n   *\n   * Example:\n   * GET /api/eventmanager/workflowDefinition/parameters/{processName}?version={version}\n   * Authorization: Basic TOKEN\n   *\n   * Returns array of parameters with:\n   * - parameterType: 1 (SingleValue) or 2 (Xml)\n   * - parameterDirection: 1 (In), 2 (Out), 3 (Optional)\n   * - name, type, schema, isSystemParameter, isVariable\n   */\n  async getParameters(\n    processName: string,\n    version?: string,\n    token?: string\n  ): Promise<any[]> {\n    const headers: Record<string, string> = {}\n\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    const queryParams = new URLSearchParams()\n    // Always add version parameter, even if empty (API requires it)\n    queryParams.append('version', version || '')\n\n    const url = `${this.apiUrl}/eventmanager/workflowDefinition/parameters/${processName}?${queryParams.toString()}`\n\n    const parameters = await this.client.get<any[]>(url, { headers })\n\n    return parameters\n  }\n\n  /**\n   * Get instance data\n   * Uses standard Authorization header\n   *\n   * Example from curl:\n   * GET /api/instances?instanceId=8d2d0e04-ea83-48f2-953d-ff858581e3df\n   * Authorization: Basic TOKEN\n   */\n  async getInstanceData(\n    instanceId: string,\n    token?: string\n  ): Promise<IProcessData> {\n    const headers: Record<string, string> = {}\n\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    const data = await this.client.get<IProcessData>(\n      `${this.apiUrl}/instances?instanceId=${instanceId}`,\n      { headers }\n    )\n\n    return data\n  }\n\n  /**\n   * Acquire pessimistic lock on instance\n   * Prevents concurrent editing\n   */\n  async acquireLock(params: {\n    instanceId: string\n    token: string\n  }): Promise<{ sessionToken: string; processData: IProcessData }> {\n    const headers: Record<string, string> = {\n      'Authorization': params.token,\n    }\n\n    const result = await this.client.post<{ sessionToken: string; processData: IProcessData }>(\n      `${this.apiUrl}/ProcessInstance/AcquireLock`,\n      { instanceId: params.instanceId },\n      { headers }\n    )\n\n    return result\n  }\n\n  /**\n   * Release pessimistic lock on instance\n   */\n  async releaseLock(params: {\n    instanceId: string\n    sessionToken: string\n  }): Promise<void> {\n    const headers: Record<string, string> = {\n      'BZ-SESSION-TOKEN': params.sessionToken,\n    }\n\n    await this.client.post<void>(\n      `${this.apiUrl}/ProcessInstance/ReleaseLock`,\n      { instanceId: params.instanceId },\n      { headers }\n    )\n  }\n\n  /**\n   * Continue instance with updated parameters\n   * Uses PUT method instead of POST\n   *\n   * Example from curl:\n   * PUT /api/instances\n   * Authorization: Basic TOKEN\n   * Content-Type: application/json\n   * {\n   *   \"eventName\": \"DemoFlow\",\n   *   \"parameters\": [...],\n   *   \"instanceId\": \"e3137f94-0ab5-4ae7-b256-10806fe92958\"\n   * }\n   */\n  async continue(\n    params: IStartProcessParams,\n    files?: File[] | IBizuitFile[],\n    token?: string\n  ): Promise<IProcessResult> {\n    if (!params.instanceId) {\n      throw new Error('instanceId is required for continue')\n    }\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    }\n\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    // Process parameters: handle XmlParameter instances and object-to-XML conversion\n    const processedParameters = (params.parameters || []).map(param => {\n      // Check if parameter is an XmlParameter instance\n      if (XmlParameter.isXmlParameter(param)) {\n        // Convert XmlParameter to IParameter and then to XML\n        const iParam = (param as XmlParameter).toParameter()\n        const xmlString = jsonToXml(iParam.value)\n        console.log(`✅ Auto-converted XmlParameter \"${iParam.name}\" to XML`)\n        return {\n          ...iParam,\n          value: xmlString\n        }\n      }\n\n      // Existing behavior: convert plain objects to XML\n      if (param.type === 'Xml' && typeof param.value === 'object' && param.value !== null) {\n        // Auto-convert JavaScript object to XML string\n        const xmlString = jsonToXml(param.value)\n        console.log(`✅ Auto-converted parameter \"${param.name}\" from object to XML`)\n        return {\n          ...param,\n          value: xmlString\n        }\n      }\n      return param\n    })\n\n    const payload: any = {\n      eventName: params.processName,\n      parameters: processedParameters,\n      instanceId: params.instanceId,\n    }\n\n    if (params.processVersion) {\n      payload.eventVersion = params.processVersion\n    }\n\n    if (params.closeOnSuccess !== undefined) {\n      payload.closeOnSuccess = params.closeOnSuccess\n    }\n\n    if (params.deletedDocuments && params.deletedDocuments.length > 0) {\n      payload.deletedDocuments = params.deletedDocuments\n    }\n\n    // Determine which files to use: from params or from files parameter\n    const filesToUpload = params.files || files\n\n    let result: IProcessResult\n\n    // Use multipart/form-data when files are present\n    if (filesToUpload && filesToUpload.length > 0) {\n      // Dashboard API: POST /api/instances/RaiseEvent with multipart (continues also use POST)\n      result = await this.client.postMultipart<IProcessResult>(\n        `${this.apiUrl}/instances/RaiseEvent`,\n        payload,\n        filesToUpload,\n        { headers: { 'BZ-AUTH-TOKEN': token } }\n      )\n    } else {\n      // Standard JSON request (existing behavior - no changes)\n      result = await this.client.put<IProcessResult>(\n        `${this.apiUrl}/instances`,\n        payload,\n        { headers }\n      )\n    }\n\n    // Automatically parse XML parameters to JSON\n    // Note: API returns tyconParameters, but we map it to parameters\n    const parametersArray = (result as any).tyconParameters || result.parameters;\n    if (parametersArray && Array.isArray(parametersArray)) {\n      parametersArray.forEach((param: any) => {\n        // Check if parameter type is 2 or \"Xml\" (XML/Complex) and has a value\n        if ((param.parameterType === 2 || param.parameterType === 'Xml') && param.value) {\n          try {\n            const parsedJson = xmlToJson(param.value)\n            if (parsedJson !== null) {\n              // Replace XML string with parsed JSON object\n              param.value = parsedJson as any\n              // Change parameterType to indicate it's now JSON\n              param.parameterType = 'Json' as any\n              console.log(`✅ Auto-parsed XML parameter: ${param.name}`)\n            } else {\n              console.warn(`⚠️ Failed to parse XML parameter: ${param.name}, keeping original XML`)\n            }\n          } catch (error) {\n            console.warn(`⚠️ Error parsing XML parameter ${param.name}:`, error)\n            // Keep original XML value on error\n          }\n        }\n      })\n\n      // Map tyconParameters to parameters for compatibility\n      if ((result as any).tyconParameters) {\n        result.parameters = parametersArray;\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Get process parameters as XmlParameter objects (NEW in v2.1.0)\n   *\n   * Returns parameters wrapped in XmlParameter instances, allowing direct property access:\n   *\n   * @example\n   * ```typescript\n   * const params = await sdk.process.getParametersAsObjects({\n   *   processName: 'MyProcess',\n   *   token: authToken\n   * })\n   *\n   * // Direct property modification via Proxy\n   * params.pSampleXml.nodo1 = 'a'\n   * params.pSampleXml.productos[0].codigo = 'ABC'\n   *\n   * // Send directly to process\n   * await sdk.process.start({\n   *   processName: 'MyProcess',\n   *   parameters: [params.pSampleXml]  // SDK auto-converts\n   * }, [], token)\n   * ```\n   *\n   * @param params - Initialize parameters (processName, version, etc.)\n   * @returns Object with parameter names as keys, XmlParameter instances as values\n   */\n  async getParametersAsObjects(\n    params: IInitializeParams\n  ): Promise<Record<string, XmlParameter>> {\n    // Get process definition with parameters\n    const processData = await this.initialize(params)\n\n    const result: Record<string, XmlParameter> = {}\n\n    // Process XML parameters only\n    if (processData.parameters && Array.isArray(processData.parameters)) {\n      processData.parameters.forEach((param: any) => {\n        // Only process XML/Complex parameters (type 2)\n        if (param.parameterType === 2 || param.parameterType === 'Xml') {\n          const paramName = param.name\n\n          // Determine direction\n          let direction: 'In' | 'Out' | 'InOut' = 'In'\n          if (param.parameterDirection === 2 || param.parameterDirection === 'Out') {\n            direction = 'Out'\n          } else if (param.parameterDirection === 3 || param.parameterDirection === 'InOut') {\n            direction = 'InOut'\n          }\n\n          // Try to parse XSD schema if available\n          let template: any = {}\n\n          if (param.schema && typeof param.schema === 'string') {\n            try {\n              template = parseXsdToTemplate(param.schema)\n              console.log(`✅ Generated template from XSD for parameter: ${paramName}`)\n            } catch (error) {\n              console.warn(`⚠️ Failed to parse XSD for ${paramName}, using empty template:`, error)\n              template = {}\n            }\n          } else {\n            console.log(`ℹ️ No XSD schema for parameter ${paramName}, using empty template`)\n            template = {}\n          }\n\n          // Create XmlParameter instance\n          const xmlParam = new XmlParameter(paramName, template, direction)\n          result[paramName] = xmlParam\n        }\n      })\n    }\n\n    return result\n  }\n\n  /**\n   * Get Bizuit configuration settings for an organization\n   * @param organizationId - Organization identifier\n   * @param token - Authentication token\n   * @returns Configuration settings object\n   */\n  async getConfigurationSettings(\n    organizationId: string,\n    token?: string\n  ): Promise<Record<string, any>> {\n    const headers: Record<string, string> = {}\n\n    if (token) {\n      headers['Authorization'] = token\n    }\n\n    const result = await this.client.get<Record<string, any>>(\n      `${this.apiUrl}/bpmn/configuration-settings?organizationId=${organizationId}`,\n      { headers }\n    )\n\n    return result\n  }\n\n  /**\n   * Get instance documents\n   * Returns list of documents attached to an instance\n   *\n   * Example:\n   * GET /api/instances/{instanceId}/documents\n   * BZ-AUTH-TOKEN: token\n   *\n   * @param instanceId - Instance ID\n   * @param token - Authentication token\n   * @returns Array of document metadata with ID, FileName, Size, Version, etc.\n   */\n  async getDocuments(instanceId: string, token?: string): Promise<any[]> {\n    const headers: Record<string, string> = {}\n\n    if (token) {\n      headers['BZ-AUTH-TOKEN'] = token\n    }\n\n    try {\n      const response = await this.client.get<any[]>(\n        `${this.apiUrl}/instances/${instanceId}/documents`,\n        { headers }\n      )\n      return response || []\n    } catch (error) {\n      console.error('Error fetching instance documents:', error)\n      return []\n    }\n  }\n\n  /**\n   * Download a document from an instance\n   * Returns the document as a Blob\n   *\n   * Example:\n   * GET /api/instances/documents/{documentId}/{version}\n   * BZ-AUTH-TOKEN: token\n   * Response: Binary data (Blob)\n   *\n   * @param documentId - Document ID\n   * @param version - Document version\n   * @param token - Authentication token\n   * @returns Document blob\n   */\n  async downloadDocument(\n    documentId: number,\n    version: number,\n    token?: string\n  ): Promise<Blob> {\n    const headers: Record<string, string> = {}\n\n    if (token) {\n      headers['BZ-AUTH-TOKEN'] = token\n    }\n\n    const response = await this.client.get<Blob>(\n      `${this.apiUrl}/instances/documents/${documentId}/${version}`,\n      {\n        headers,\n        responseType: 'blob'\n      }\n    )\n\n    return response\n  }\n}\n","/**\n * Bizuit Instance Lock Service\n * Handles pessimistic locking for process instances\n */\n\nimport { BizuitHttpClient } from './http-client'\nimport type {\n  IBizuitConfig,\n  ILockStatus,\n  ILockRequest,\n  IUnlockRequest,\n} from '../types'\n\nexport class BizuitInstanceLockService {\n  private client: BizuitHttpClient\n  private apiUrl: string\n\n  constructor(config: IBizuitConfig) {\n    this.client = new BizuitHttpClient(config)\n    this.apiUrl = config.apiUrl\n  }\n\n  /**\n   * Check if instance is locked\n   */\n  async checkLockStatus(\n    instanceId: string,\n    activityName: string,\n    token: string\n  ): Promise<ILockStatus> {\n    this.client.withBizuitHeaders({\n      'BZ-AUTH-TOKEN': token,\n    })\n\n    const status = await this.client.get<boolean>(\n      `${this.apiUrl}/instances/status/${instanceId}?activityName=${activityName}`\n    )\n\n    this.client.clearBizuitHeaders()\n\n    return {\n      available: status,\n    }\n  }\n\n  /**\n   * Lock instance for editing\n   */\n  async lock(\n    request: ILockRequest,\n    token: string\n  ): Promise<ILockStatus> {\n    this.client.withBizuitHeaders({\n      'BZ-AUTH-TOKEN': token,\n    })\n\n    const queryParams = new URLSearchParams({\n      activityName: request.activityName,\n      operation: String(request.operation),\n      processName: request.processName,\n    })\n\n    const result = await this.client.patch<ILockStatus>(\n      `${this.apiUrl}/instances/lock/${request.instanceId}?${queryParams.toString()}`\n    )\n\n    this.client.clearBizuitHeaders()\n\n    return result\n  }\n\n  /**\n   * Unlock instance\n   */\n  async unlock(\n    request: IUnlockRequest,\n    token: string\n  ): Promise<ILockStatus> {\n    this.client.withBizuitHeaders({\n      'BZ-AUTH-TOKEN': token,\n    })\n\n    const result = await this.client.patch<ILockStatus>(\n      `${this.apiUrl}/instances/unlock/${request.instanceId}`,\n      request\n    )\n\n    this.client.clearBizuitHeaders()\n\n    return result\n  }\n\n  /**\n   * Execute a callback with automatic lock/unlock\n   * Ensures instance is always unlocked even if callback throws\n   */\n  async withLock<T>(\n    request: ILockRequest,\n    token: string,\n    callback: (sessionToken: string) => Promise<T>\n  ): Promise<T> {\n    // Lock instance\n    const lockResult = await this.lock(request, token)\n\n    if (!lockResult.available) {\n      throw new Error(\n        `Instance is locked by ${lockResult.user}. Reason: ${lockResult.reason}`\n      )\n    }\n\n    const sessionToken = lockResult.sessionToken || ''\n\n    try {\n      // Execute callback\n      const result = await callback(sessionToken)\n      return result\n    } finally {\n      // Always unlock, even if callback throws\n      try {\n        await this.unlock(\n          {\n            instanceId: request.instanceId,\n            activityName: request.activityName,\n            sessionToken,\n          },\n          token\n        )\n      } catch (unlockError) {\n        console.error('[BizuitInstanceLockService] Failed to unlock instance:', unlockError)\n      }\n    }\n  }\n\n  /**\n   * Force unlock (admin only)\n   * Use with caution\n   */\n  async forceUnlock(\n    instanceId: string,\n    activityName: string,\n    token: string\n  ): Promise<void> {\n    await this.unlock(\n      {\n        instanceId,\n        activityName,\n      },\n      token\n    )\n  }\n}\n","/**\n * Form utilities for converting form data to Bizuit API format\n */\n\nimport type { IParameter } from '../types'\n\n/**\n * Bizuit Process Parameter from API\n * Structure returned by getProcessParameters endpoint\n */\nexport interface IBizuitProcessParameter {\n  name: string\n  parameterType: number // 1 = SingleValue, 2 = Xml\n  parameterDirection: number // 1 = In, 2 = Out, 3 = Optional\n  type: string // 'string', 'int', 'bool', etc.\n  schema: string // XSD schema\n  value: string | null\n  isSystemParameter: boolean\n  isVariable: boolean\n}\n\n/**\n * Filters process parameters to get only those that should be displayed in the START PROCESS form\n * Excludes system parameters, variables, and output-only parameters\n *\n * @param parameters - Array of process parameters from getProcessParameters\n * @returns Filtered array of parameters for START process form display\n *\n * @example\n * ```typescript\n * const allParams = await sdk.process.getProcessParameters('MyProcess', '', token)\n * const formParams = filterFormParameters(allParams)\n * // Returns only input (direction=1) and optional (direction=3) parameters\n * // that are not system parameters or variables\n * ```\n */\nexport function filterFormParameters(\n  parameters: IBizuitProcessParameter[]\n): IBizuitProcessParameter[] {\n  return parameters.filter((param) => {\n    // Exclude system parameters and variables\n    if (param.isSystemParameter || param.isVariable) {\n      return false\n    }\n\n    // Include only Input (1) and Optional (3) parameters\n    // Exclude Output (2) parameters\n    return param.parameterDirection === 1 || param.parameterDirection === 3\n  })\n}\n\n/**\n * Filters process parameters to get only those that should be displayed in the CONTINUE PROCESS form\n * Includes Input, Optional, AND Variables (different from filterFormParameters)\n * Excludes only system parameters and output-only parameters\n *\n * @param parameters - Array of process parameters from getProcessParameters\n * @returns Filtered array of parameters for CONTINUE process form display\n *\n * @example\n * ```typescript\n * const allParams = await sdk.process.getProcessParameters('MyProcess', '', token)\n * const formParams = filterContinueParameters(allParams)\n * // Returns input (direction=1), optional (direction=3) parameters,\n * // AND variables (isVariable=true) that are not system parameters\n * ```\n */\nexport function filterContinueParameters(\n  parameters: IBizuitProcessParameter[]\n): IBizuitProcessParameter[] {\n  return parameters.filter((param) => {\n    // Exclude system parameters\n    if (param.isSystemParameter) {\n      return false\n    }\n\n    // Include Variables (this is the main difference from filterFormParameters)\n    if (param.isVariable) {\n      return true\n    }\n\n    // Include Input (1) and Optional (3) parameters\n    // Exclude Output-only (2) parameters\n    return param.parameterDirection === 1 || param.parameterDirection === 3\n  })\n}\n\n/**\n * Checks if a parameter is required or optional\n *\n * @param param - Process parameter\n * @returns true if parameter is required (direction=1), false if optional (direction=3)\n */\nexport function isParameterRequired(param: IBizuitProcessParameter): boolean {\n  return param.parameterDirection === 1\n}\n\n/**\n * Gets a human-readable label for parameter direction\n *\n * @param direction - Parameter direction number\n * @returns Human-readable label\n */\nexport function getParameterDirectionLabel(direction: number): string {\n  switch (direction) {\n    case 1:\n      return 'Input'\n    case 2:\n      return 'Output'\n    case 3:\n      return 'Optional'\n    default:\n      return 'Unknown'\n  }\n}\n\n/**\n * Gets a human-readable label for parameter type\n *\n * @param parameterType - Parameter type number\n * @returns Human-readable label\n */\nexport function getParameterTypeLabel(parameterType: number): string {\n  switch (parameterType) {\n    case 1:\n      return 'SingleValue'\n    case 2:\n      return 'Xml'\n    default:\n      return 'Unknown'\n  }\n}\n\n/**\n * Converts form data to IParameter[] format expected by Bizuit API\n *\n * @param formData - Object with form field values\n * @returns Array of IParameter objects\n *\n * @example\n * ```typescript\n * const formData = {\n *   priority: 'high',\n *   categories: ['sales', 'support'],\n *   startDate: new Date(),\n *   budget: 75,\n *   description: 'Process description',\n *   files: [file1, file2]\n * }\n *\n * const parameters = formDataToParameters(formData)\n * // Returns:\n * // [\n * //   { name: 'priority', value: 'high', type: 'SingleValue', direction: 'In' },\n * //   { name: 'categories', value: '[\"sales\",\"support\"]', type: 'SingleValue', direction: 'In' },\n * //   ...\n * // ]\n * ```\n */\nexport function formDataToParameters(formData: Record<string, any>): IParameter[] {\n  const parameters: IParameter[] = []\n\n  for (const [key, value] of Object.entries(formData)) {\n    // Skip undefined, null, or empty values\n    if (value === undefined || value === null || value === '') {\n      continue\n    }\n\n    // Skip file objects - files are handled separately in the SDK\n    if (value instanceof File || (Array.isArray(value) && value.length > 0 && value[0] instanceof File)) {\n      continue\n    }\n\n    // Convert value to string based on type\n    let stringValue: string\n    let paramType: 'SingleValue' | 'Xml' | 'ComplexObject' = 'SingleValue'\n\n    if (Array.isArray(value)) {\n      // Array values: convert to JSON string\n      stringValue = JSON.stringify(value)\n    } else if (value instanceof Date) {\n      // Date values: convert to ISO string\n      stringValue = value.toISOString()\n    } else if (typeof value === 'object') {\n      // Complex objects: convert to JSON string and mark as ComplexObject\n      stringValue = JSON.stringify(value)\n      paramType = 'ComplexObject'\n    } else if (typeof value === 'boolean') {\n      // Boolean values: convert to 'true' or 'false' string\n      stringValue = value.toString()\n    } else {\n      // Primitive values: convert to string\n      stringValue = String(value)\n    }\n\n    parameters.push({\n      name: key,\n      value: stringValue,\n      type: paramType,\n      direction: 'In',\n    })\n  }\n\n  return parameters\n}\n\n/**\n * Converts IParameter[] back to form data object\n * Useful for loading existing instance data into the form\n *\n * @param parameters - Array of IParameter objects\n * @returns Object with form field values\n *\n * @example\n * ```typescript\n * const parameters = [\n *   { name: 'priority', value: 'high', type: 'SingleValue', direction: 'In' },\n *   { name: 'categories', value: '[\"sales\",\"support\"]', type: 'SingleValue', direction: 'In' }\n * ]\n *\n * const formData = parametersToFormData(parameters)\n * // Returns: { priority: 'high', categories: ['sales', 'support'] }\n * ```\n */\nexport function parametersToFormData(parameters: IParameter[]): Record<string, any> {\n  const formData: Record<string, any> = {}\n\n  for (const param of parameters) {\n    if (!param.value) continue\n\n    try {\n      // Try to parse as JSON first (for arrays and objects)\n      const parsedValue = JSON.parse(param.value)\n      formData[param.name] = parsedValue\n    } catch {\n      // If parsing fails, it's a simple string value\n      // Try to detect if it's a date\n      if (isISODate(param.value)) {\n        formData[param.name] = new Date(param.value)\n      } else if (param.value === 'true' || param.value === 'false') {\n        // Convert string boolean to actual boolean\n        formData[param.name] = param.value === 'true'\n      } else if (!isNaN(Number(param.value)) && param.value.trim() !== '') {\n        // Convert numeric strings to numbers\n        formData[param.name] = Number(param.value)\n      } else {\n        // Keep as string\n        formData[param.name] = param.value\n      }\n    }\n  }\n\n  return formData\n}\n\n/**\n * Helper function to detect if a string is an ISO date\n */\nfunction isISODate(str: string): boolean {\n  const isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/\n  return isoDateRegex.test(str)\n}\n\n/**\n * Creates a parameter with explicit type and direction\n * Useful for creating specific parameters that need custom configuration\n *\n * @param name - Parameter name\n * @param value - Parameter value\n * @param type - Parameter type (default: 'SingleValue')\n * @param direction - Parameter direction (default: 'In')\n * @returns IParameter object\n *\n * @example\n * ```typescript\n * const param = createParameter('userId', '12345', 'SingleValue', 'In')\n * ```\n */\nexport function createParameter(\n  name: string,\n  value: any,\n  type: 'SingleValue' | 'Xml' | 'ComplexObject' = 'SingleValue',\n  direction: 'In' | 'Out' | 'InOut' = 'In'\n): IParameter {\n  return {\n    name,\n    value: typeof value === 'string' ? value : JSON.stringify(value),\n    type,\n    direction,\n  }\n}\n\n/**\n * Merges multiple parameter arrays, with later arrays overriding earlier ones\n * Useful for combining default parameters with form data\n *\n * @param parameterArrays - Arrays of parameters to merge\n * @returns Merged array of parameters\n *\n * @example\n * ```typescript\n * const defaults = [{ name: 'status', value: 'pending', type: 'SingleValue', direction: 'In' }]\n * const formParams = formDataToParameters(formData)\n * const merged = mergeParameters(defaults, formParams)\n * ```\n */\nexport function mergeParameters(...parameterArrays: IParameter[][]): IParameter[] {\n  const paramMap = new Map<string, IParameter>()\n\n  for (const params of parameterArrays) {\n    for (const param of params) {\n      paramMap.set(param.name, param)\n    }\n  }\n\n  return Array.from(paramMap.values())\n}\n\n/**\n * Lock information returned by loadInstanceDataForContinue\n */\nexport interface ILockInfo {\n  /** Whether the instance is currently locked by this user */\n  isLocked: boolean\n  /** Session token for unlocking (only present if isLocked is true) */\n  sessionToken?: string\n  /** User who has the lock (only present if locked by another user) */\n  lockedBy?: string\n  /** Reason for lock failure (only present if lock failed) */\n  lockFailReason?: string\n}\n\n/**\n * Result type for loadInstanceDataForContinue helper\n */\nexport interface ILoadInstanceDataResult {\n  instanceData: any\n  processName: string\n  eventName: string\n  formParameters: IBizuitProcessParameter[]\n  formData: Record<string, any>\n  /** Lock information (only present if autoLock was requested) */\n  lockInfo?: ILockInfo\n}\n\n/**\n * Maps Bizuit API parameter structure to IBizuitProcessParameter format\n * API returns different field names and structure\n */\nfunction mapApiParameterToInternal(apiParam: any): IParameter {\n  return {\n    name: apiParam.name,\n    value: typeof apiParam.value === 'object' ? JSON.stringify(apiParam.value) : String(apiParam.value || ''),\n    type: apiParam.parameterType === 'SingleValue' ? 'SingleValue' : apiParam.parameterType === 'Xml' ? 'Xml' : 'SingleValue',\n    direction: apiParam.parameterDirection === 'In' ? 'In' : apiParam.parameterDirection === 'Out' ? 'Out' : apiParam.parameterDirection === 'Optional' ? 'InOut' : 'In',\n  }\n}\n\n/**\n * Converts API parameter structure to IBizuitProcessParameter\n * for form rendering\n */\nfunction mapApiParameterToFormParameter(apiParam: any): IBizuitProcessParameter {\n  // Map parameterDirection string to number\n  let direction = 1 // Default In\n  if (apiParam.parameterDirection === 'Out') direction = 2\n  else if (apiParam.parameterDirection === 'Optional') direction = 3\n  else if (apiParam.parameterDirection === 'In') direction = 1\n\n  // Map parameterType\n  let paramType = 1 // Default SingleValue\n  if (apiParam.parameterType === 'Xml') paramType = 2\n\n  return {\n    name: apiParam.name,\n    parameterType: paramType,\n    parameterDirection: direction,\n    type: guessTypeFromValue(apiParam.value),\n    schema: '',\n    value: typeof apiParam.value === 'object' ? JSON.stringify(apiParam.value) : String(apiParam.value || ''),\n    isSystemParameter: apiParam.name === 'InstanceId' || apiParam.name === 'LoggedUser' || apiParam.name === 'ExceptionParameter',\n    isVariable: false, // API doesn't distinguish, assume false for now\n  }\n}\n\n/**\n * Guess data type from value for form rendering\n */\nfunction guessTypeFromValue(value: any): string {\n  if (value === null || value === undefined || value === '') return 'string'\n  if (typeof value === 'boolean') return 'bool'\n  if (typeof value === 'number') return 'int'\n  if (typeof value === 'object') return 'string' // Will be JSON\n\n  // Try to parse as number\n  if (!isNaN(Number(value)) && value.toString().trim() !== '') return 'int'\n\n  return 'string'\n}\n\n/**\n * Options for loadInstanceDataForContinue helper\n */\nexport interface ILoadInstanceDataOptions {\n  /** Instance ID to load */\n  instanceId: string\n  /** Activity name (required if autoLock is true) */\n  activityName?: string\n  /** Process name (required if autoLock is true) */\n  processName?: string\n  /** Automatically acquire lock for editing (default: false) */\n  autoLock?: boolean\n  /** Lock operation type (default: 1 = Edit) */\n  lockOperation?: number\n}\n\n/**\n * Helper function to load all necessary data for continuing a process instance\n * This encapsulates the business logic of:\n * 1. Getting instance data with parameters\n * 2. Converting API parameters to form-friendly format\n * 3. Filtering editable parameters (excludes Output-only and system params)\n * 4. Parsing existing parameter values into form data\n * 5. Optionally acquiring a pessimistic lock for editing\n *\n * @param sdk - Bizuit SDK instance with process and lock services\n * @param options - Configuration options\n * @param token - Authentication token\n * @returns Promise with all data needed to render continue form\n *\n * @example\n * ```typescript\n * // Load without lock (read-only)\n * const result = await loadInstanceDataForContinue(sdk, {\n *   instanceId: '123-456-789'\n * }, token)\n *\n * // Load with automatic lock (for editing)\n * const result = await loadInstanceDataForContinue(sdk, {\n *   instanceId: '123-456-789',\n *   activityName: 'ReviewTask',\n *   processName: 'ApprovalProcess',\n *   autoLock: true\n * }, token)\n *\n * // Check lock status\n * if (result.lockInfo?.isLocked) {\n *   console.log('Locked with session:', result.lockInfo.sessionToken)\n * }\n * ```\n */\nexport async function loadInstanceDataForContinue(\n  sdk: any, // TODO: Type this properly as BizuitSDK\n  options: string | ILoadInstanceDataOptions, // Support old API (string) and new API (options object)\n  token: string\n): Promise<ILoadInstanceDataResult> {\n  // Handle backward compatibility: if options is a string, treat it as instanceId\n  const opts: ILoadInstanceDataOptions = typeof options === 'string'\n    ? { instanceId: options, autoLock: false }\n    : options\n\n  const { instanceId, activityName, processName, autoLock = false, lockOperation = 1 } = opts\n\n  // 1. Get instance data\n  const instanceData = await sdk.process.getInstanceData(instanceId, token)\n\n  let formParameters: IBizuitProcessParameter[] = []\n  let formData: Record<string, any> = {}\n  let lockInfo: ILockInfo | undefined\n\n  // 2. Parse parameters from API response\n  // API structure: results.tyconParameters.tyconParameter[]\n  const apiParameters = instanceData?.results?.tyconParameters?.tyconParameter\n\n  if (apiParameters && Array.isArray(apiParameters)) {\n    // Convert API structure to IBizuitProcessParameter[]\n    const allParams = apiParameters.map(mapApiParameterToFormParameter)\n\n    // Filter for continue form (excludes Output-only and system params)\n    formParameters = allParams.filter(param => {\n      // Exclude system parameters\n      if (param.isSystemParameter) return false\n\n      // Exclude Output-only (direction = 2)\n      if (param.parameterDirection === 2) return false\n\n      // Include Input (1), Optional (3), and Variables\n      return true\n    })\n\n    // Convert API parameter structure to IParameter[] for form data\n    const parameters = apiParameters.map(mapApiParameterToInternal)\n    formData = parametersToFormData(parameters)\n  }\n\n  // 3. Optionally acquire lock for editing\n  if (autoLock) {\n    if (!activityName || !processName) {\n      throw new Error('activityName and processName are required when autoLock is true')\n    }\n\n    try {\n      // Try to acquire lock\n      const lockResult = await sdk.lock.lock(\n        {\n          instanceId,\n          activityName,\n          processName,\n          operation: lockOperation,\n        },\n        token\n      )\n\n      if (lockResult.available) {\n        lockInfo = {\n          isLocked: true,\n          sessionToken: lockResult.sessionToken,\n        }\n      } else {\n        lockInfo = {\n          isLocked: false,\n          lockedBy: lockResult.user,\n          lockFailReason: lockResult.reason || 'Instance is locked by another user',\n        }\n      }\n    } catch (err: any) {\n      // Lock failed - provide error info but don't throw\n      // This allows the app to decide how to handle lock failures\n      lockInfo = {\n        isLocked: false,\n        lockFailReason: err.message || 'Failed to acquire lock',\n      }\n    }\n  }\n\n  return {\n    instanceData,\n    processName: processName || '', // Use provided processName if available\n    eventName: '', // Must be provided by user separately\n    formParameters,\n    formData,\n    lockInfo,\n  }\n}\n\n/**\n * Release a lock acquired by loadInstanceDataForContinue\n *\n * This is a convenience helper that wraps sdk.lock.unlock().\n * Use this to release locks when canceling edits or after successful submit.\n *\n * @param sdk - Bizuit SDK instance with lock service\n * @param options - Lock release options\n * @param token - Authentication token\n * @returns Promise that resolves when lock is released\n *\n * @example\n * ```typescript\n * // After loading with lock\n * const result = await loadInstanceDataForContinue(sdk, {\n *   instanceId: '123',\n *   activityName: 'Task',\n *   processName: 'Process',\n *   autoLock: true\n * }, token)\n *\n * // ... user cancels or finishes editing ...\n *\n * // Release the lock\n * if (result.lockInfo?.sessionToken) {\n *   await releaseInstanceLock(sdk, {\n *     instanceId: '123',\n *     activityName: 'Task',\n *     sessionToken: result.lockInfo.sessionToken\n *   }, token)\n * }\n * ```\n */\nexport async function releaseInstanceLock(\n  sdk: any,\n  options: {\n    instanceId: string\n    activityName: string\n    sessionToken: string\n  },\n  token: string\n): Promise<void> {\n  try {\n    await sdk.lock.unlock(options, token)\n  } catch (err: any) {\n    // Silently fail - lock will expire eventually\n    if (process.env.NODE_ENV === 'development') {\n      console.warn('[releaseInstanceLock] Failed to release lock:', err.message)\n    }\n  }\n}\n\n/**\n * Processes a URL token and creates a mock login response\n * This is useful when Bizuit BPM passes a token via URL parameter\n *\n * @param token - The authentication token from URL\n * @param username - Optional username (defaults to 'bizuit-user')\n * @param displayName - Optional display name (defaults to 'Usuario Bizuit')\n * @param expirationHours - Token expiration in hours (defaults to 24)\n * @returns ILoginResponse object ready for auth context\n *\n * @example\n * ```typescript\n * import { processUrlToken } from '@bizuit/form-sdk'\n *\n * const urlToken = searchParams.get('token')\n * if (urlToken) {\n *   const loginResponse = processUrlToken(urlToken)\n *   setAuthData(loginResponse)\n * }\n * ```\n */\nexport function processUrlToken(\n  token: string,\n  username: string = 'bizuit-user',\n  displayName: string = 'Usuario Bizuit',\n  expirationHours: number = 24\n): {\n  Token: string\n  User: {\n    Username: string\n    UserID: number\n    DisplayName: string\n  }\n  ExpirationDate: string\n} {\n  return {\n    Token: token,\n    User: {\n      Username: username,\n      UserID: 0,\n      DisplayName: displayName,\n    },\n    ExpirationDate: new Date(Date.now() + expirationHours * 60 * 60 * 1000).toISOString(),\n  }\n}\n\n/**\n * Parameter mapping configuration\n * Maps form fields to Bizuit parameters/variables with optional transformation\n */\nexport interface IParameterMapping {\n  /** Name of the Bizuit parameter or variable */\n  parameterName: string\n  /** Whether this is a variable (true) or parameter (false). Default: false */\n  isVariable?: boolean\n  /** Optional function to transform the form value before sending */\n  transform?: (value: any) => any\n  /** Parameter type. Default: 'SingleValue' */\n  type?: 'SingleValue' | 'Xml' | 'ComplexObject'\n  /** Parameter direction. Default: 'In' */\n  direction?: 'In' | 'Out' | 'InOut'\n}\n\n/**\n * Builds parameters array by selectively mapping form fields to Bizuit parameters/variables\n *\n * This function gives you complete control over which form fields are sent as parameters,\n * allowing you to:\n * - Map form field names to different parameter names\n * - Specify which fields are variables vs parameters\n * - Transform values before sending\n * - Send only specific fields instead of all form data\n *\n * @param mapping - Object mapping form field names to parameter configuration\n * @param formData - Form data object\n * @returns Array of IParameter objects ready for Bizuit API\n *\n * @example\n * ```typescript\n * // Map form fields to parameters and variables\n * const parameters = buildParameters({\n *   // Simple mapping: form field 'empleado' → parameter 'pEmpleado'\n *   'empleado': {\n *     parameterName: 'pEmpleado'\n *   },\n *\n *   // Map to different name with transformation\n *   'monto': {\n *     parameterName: 'pMonto',\n *     transform: (val) => parseFloat(val).toFixed(2)\n *   },\n *\n *   // Map to a variable (for continue process)\n *   'aprobado': {\n *     parameterName: 'vAprobado',\n *     isVariable: true\n *   },\n *\n *   // Complex object with custom type\n *   'detalles': {\n *     parameterName: 'pDetalles',\n *     type: 'ComplexObject'\n *   }\n * }, formData)\n *\n * // Only fields in mapping are included, all others are ignored\n * ```\n *\n * @example\n * ```typescript\n * // Continue process with selective fields\n * const parameters = buildParameters({\n *   // Only send these 2 fields, ignore all others\n *   'comentarios': { parameterName: 'pComentarios' },\n *   'estadoAprobacion': {\n *     parameterName: 'vEstado',\n *     isVariable: true\n *   }\n * }, formData)\n *\n * await sdk.process.raiseEvent({\n *   eventName: 'AprobacionVacaciones',\n *   instanceId: 'existing-instance-id',\n *   parameters\n * }, [], token)\n * ```\n */\nexport function buildParameters(\n  mapping: Record<string, IParameterMapping>,\n  formData: Record<string, any>\n): IParameter[] {\n  const parameters: IParameter[] = []\n\n  // Iterate over the mapping (not formData) to ensure we only include mapped fields\n  for (const [formFieldName, config] of Object.entries(mapping)) {\n    // Get value from form data\n    let value = formData[formFieldName]\n\n    // Skip if value doesn't exist in form data\n    if (value === undefined) {\n      continue\n    }\n\n    // Skip null or empty values (unless explicitly transformed)\n    if ((value === null || value === '') && !config.transform) {\n      continue\n    }\n\n    // Apply transformation if provided\n    if (config.transform) {\n      value = config.transform(value)\n    }\n\n    // Convert value to string based on type\n    let stringValue: string\n    let paramType: 'SingleValue' | 'Xml' | 'ComplexObject' = config.type || 'SingleValue'\n\n    if (value instanceof File || (Array.isArray(value) && value.length > 0 && value[0] instanceof File)) {\n      // Skip file objects - files are handled separately\n      continue\n    } else if (Array.isArray(value)) {\n      stringValue = JSON.stringify(value)\n    } else if (value instanceof Date) {\n      stringValue = value.toISOString()\n    } else if (typeof value === 'object' && value !== null) {\n      stringValue = JSON.stringify(value)\n      if (!config.type) {\n        paramType = 'ComplexObject'\n      }\n    } else if (typeof value === 'boolean') {\n      stringValue = value.toString()\n    } else {\n      stringValue = String(value)\n    }\n\n    // Create parameter\n    parameters.push({\n      name: config.parameterName,\n      value: stringValue,\n      type: paramType,\n      direction: config.direction || 'In',\n    })\n  }\n\n  return parameters\n}\n","/**\n * Bizuit Form Service\n * High-level service for common form workflows\n *\n * Provides simplified methods that encapsulate common patterns:\n * - Starting new processes with form data + additional parameters\n * - Continuing existing processes with selective field mapping\n * - Managing locks automatically\n *\n * Use this service for common cases. For advanced control, use BizuitProcessService directly.\n */\n\nimport type { IParameter, IProcessResult } from '../types'\nimport {\n  buildParameters,\n  formDataToParameters,\n  createParameter,\n  loadInstanceDataForContinue,\n  releaseInstanceLock,\n  type IParameterMapping,\n  type ILockInfo,\n  type IBizuitProcessParameter,\n} from '../utils/form-utils'\n\nexport class BizuitFormService {\n  constructor(private sdk: any) {}\n\n  /**\n   * Prepares a form for STARTING a new process\n   *\n   * @returns Parameters ready to render the form\n   */\n  async prepareStartForm(options: {\n    processName: string\n    version?: string\n    token: string\n  }): Promise<{\n    parameters: IBizuitProcessParameter[]\n    formData: Record<string, any>\n  }> {\n    // Get process definition\n    const processData = await this.sdk.process.initialize({\n      processName: options.processName,\n      version: options.version,\n      token: options.token\n    })\n\n    // Filter parameters for start form\n    const parameters = processData.parameters || []\n\n    // Convert to formData (with default values)\n    const formData: Record<string, any> = {}\n    parameters.forEach((param: any) => {\n      if (param.value !== null && param.value !== undefined) {\n        formData[param.name] = param.value\n      }\n    })\n\n    return { parameters, formData }\n  }\n\n  /**\n   * Starts a new process combining:\n   * - Parameters mapped from form fields\n   * - Additional parameters (not associated with fields)\n   *\n   * @example\n   * ```typescript\n   * // Only form data (send all fields)\n   * await formService.startProcess({\n   *   processName: 'ExpenseRequest',\n   *   token,\n   *   formData: { empleado: 'Juan', monto: '5000' }\n   * })\n   *\n   * // Form data with selective mapping\n   * await formService.startProcess({\n   *   processName: 'ExpenseRequest',\n   *   token,\n   *   formData,\n   *   fieldMapping: {\n   *     'empleado': { parameterName: 'pEmpleado' },\n   *     'monto': {\n   *       parameterName: 'pMonto',\n   *       transform: (val) => parseFloat(val).toFixed(2)\n   *     }\n   *   }\n   * })\n   *\n   * // Form data + additional parameters\n   * await formService.startProcess({\n   *   processName: 'ExpenseRequest',\n   *   token,\n   *   formData,\n   *   fieldMapping,\n   *   additionalParameters: formService.createParameters([\n   *     { name: 'pUsuarioCreador', value: currentUser.username },\n   *     { name: 'pFechaCreacion', value: new Date().toISOString() }\n   *   ])\n   * })\n   * ```\n   */\n  async startProcess(options: {\n    processName: string\n    processVersion?: string\n    formData?: Record<string, any>\n    fieldMapping?: Record<string, IParameterMapping>\n    additionalParameters?: IParameter[]\n    files?: File[]\n    token: string\n  }): Promise<IProcessResult> {\n    const parameters: IParameter[] = []\n\n    // 1. Parameters from form fields (with selective mapping)\n    if (options.formData && options.fieldMapping) {\n      const mappedParams = buildParameters(options.fieldMapping, options.formData)\n      parameters.push(...mappedParams)\n    } else if (options.formData && !options.fieldMapping) {\n      // No mapping: send all fields\n      const allParams = formDataToParameters(options.formData)\n      parameters.push(...allParams)\n    }\n\n    // 2. Additional parameters (not associated with fields)\n    if (options.additionalParameters) {\n      parameters.push(...options.additionalParameters)\n    }\n\n    // 3. Start the process with all parameters\n    return await this.sdk.process.start({\n      processName: options.processName,\n      processVersion: options.processVersion,\n      parameters\n    }, options.files, options.token)\n  }\n\n  /**\n   * Prepares a form for CONTINUING an existing instance\n   *\n   * @returns Instance data ready to render and edit\n   */\n  async prepareContinueForm(options: {\n    instanceId: string\n    processName: string\n    activityName?: string\n    autoLock?: boolean\n    token: string\n  }): Promise<{\n    parameters: IBizuitProcessParameter[]\n    formData: Record<string, any>\n    lockInfo?: ILockInfo\n    instanceData: any\n  }> {\n    // Use existing helper (already does everything)\n    const result = await loadInstanceDataForContinue(\n      this.sdk,\n      {\n        instanceId: options.instanceId,\n        processName: options.processName,\n        activityName: options.activityName,\n        autoLock: options.autoLock\n      },\n      options.token\n    )\n\n    return {\n      parameters: result.formParameters,\n      formData: result.formData,\n      lockInfo: result.lockInfo,\n      instanceData: result.instanceData\n    }\n  }\n\n  /**\n   * Continues an existing process combining:\n   * - Parameters mapped from form fields\n   * - Additional parameters (not associated with fields)\n   *\n   * @example\n   * ```typescript\n   * // Form data + context parameters\n   * await formService.continueProcess({\n   *   instanceId: '123-456',\n   *   processName: 'ExpenseRequest',\n   *   token,\n   *   formData,\n   *   fieldMapping: {\n   *     'aprobado': {\n   *       parameterName: 'vAprobado',\n   *       isVariable: true\n   *     },\n   *     'comentarios': { parameterName: 'pComentarios' }\n   *   },\n   *   additionalParameters: formService.createParameters([\n   *     { name: 'vAprobador', value: currentUser.username },\n   *     { name: 'vFechaAprobacion', value: new Date().toISOString() }\n   *   ])\n   * })\n   * ```\n   */\n  async continueProcess(options: {\n    instanceId: string\n    processName: string\n    formData?: Record<string, any>\n    fieldMapping?: Record<string, IParameterMapping>\n    additionalParameters?: IParameter[]\n    files?: File[]\n    token: string\n  }): Promise<IProcessResult> {\n    const parameters: IParameter[] = []\n\n    // 1. Parameters from form fields\n    if (options.formData && options.fieldMapping) {\n      const mappedParams = buildParameters(options.fieldMapping, options.formData)\n      parameters.push(...mappedParams)\n    } else if (options.formData && !options.fieldMapping) {\n      const allParams = formDataToParameters(options.formData)\n      parameters.push(...allParams)\n    }\n\n    // 2. Additional parameters\n    if (options.additionalParameters) {\n      parameters.push(...options.additionalParameters)\n    }\n\n    // 3. Continue the process\n    return await this.sdk.process.continue({\n      processName: options.processName,\n      instanceId: options.instanceId,\n      parameters\n    }, options.files, options.token)\n  }\n\n  /**\n   * Releases a lock acquired during prepareContinueForm\n   */\n  async releaseLock(options: {\n    instanceId: string\n    activityName: string\n    sessionToken: string\n    token: string\n  }): Promise<void> {\n    return await releaseInstanceLock(\n      this.sdk,\n      {\n        instanceId: options.instanceId,\n        activityName: options.activityName,\n        sessionToken: options.sessionToken\n      },\n      options.token\n    )\n  }\n\n  /**\n   * Helper to create a single parameter easily\n   */\n  createParameter(\n    name: string,\n    value: any,\n    options?: {\n      type?: 'SingleValue' | 'Xml' | 'ComplexObject'\n      direction?: 'In' | 'Out' | 'InOut'\n    }\n  ): IParameter {\n    return createParameter(\n      name,\n      value,\n      options?.type || 'SingleValue',\n      options?.direction || 'In'\n    )\n  }\n\n  /**\n   * Helper to create multiple parameters easily\n   *\n   * @example\n   * ```typescript\n   * const params = formService.createParameters([\n   *   { name: 'pUsuario', value: currentUser.username },\n   *   { name: 'pFecha', value: new Date().toISOString() },\n   *   { name: 'pConfig', value: { theme: 'dark' }, type: 'ComplexObject' }\n   * ])\n   * ```\n   */\n  createParameters(params: Array<{\n    name: string\n    value: any\n    type?: 'SingleValue' | 'Xml' | 'ComplexObject'\n    direction?: 'In' | 'Out' | 'InOut'\n  }>): IParameter[] {\n    return params.map(p => this.createParameter(p.name, p.value, {\n      type: p.type,\n      direction: p.direction\n    }))\n  }\n}\n","/**\n * Bizuit DataService Service\n * Executes queries via BIZUIT Dashboard DataService API\n */\n\nimport { BizuitHttpClient } from './http-client'\nimport type {\n  IBizuitConfig,\n  IDataServiceRequest,\n  IDataServiceResponse,\n  IDataServiceParameter,\n  IDataServiceMetadata,\n  IDataServiceExecuteByNameRequest,\n  IPageMetadata,\n  IDataServiceExecuteByPageAndNameRequest,\n} from '../types'\n\nexport class BizuitDataServiceService {\n  private client: BizuitHttpClient\n  private apiUrl: string\n\n  constructor(config: IBizuitConfig) {\n    this.client = new BizuitHttpClient(config)\n    this.apiUrl = config.apiUrl\n  }\n\n  /**\n   * Execute a DataService query\n   *\n   * @example\n   * ```typescript\n   * // Get list of rejection types\n   * const result = await sdk.dataService.execute<RejectionType>({\n   *   id: 42,\n   *   parameters: [\n   *     { name: 'status', value: 'active' }\n   *   ]\n   * }, token)\n   *\n   * console.log(result.data) // Array of RejectionType[]\n   * ```\n   */\n  async execute<T = any>(\n    request: IDataServiceRequest,\n    token: string\n  ): Promise<IDataServiceResponse<T>> {\n    const { id, parameters = [], withoutCache = false, executeFromGlobal = false } = request\n\n    // Build query params\n    const queryParams = new URLSearchParams({\n      withoutCache: String(withoutCache),\n      executeFromGlobal: String(executeFromGlobal),\n    })\n\n    // Build request body\n    const body = {\n      id,\n      parameters: parameters.map(p => ({\n        name: p.name,\n        value: p.value,\n        isGroupBy: p.isGroupBy ?? false,\n      })),\n    }\n\n    try {\n      const response = await this.client.post<any>(\n        `${this.apiUrl}/Dashboard/DataService/Execute?${queryParams.toString()}`,\n        body,\n        {\n          headers: {\n            'bz-auth-token': `Basic ${token}`,\n          },\n        }\n      )\n\n      // Transform gridData structure to flat array of objects\n      let flattenedData: T[] = []\n\n      if (response.gridData && Array.isArray(response.gridData) && response.gridData.length > 0) {\n        const gridTable = response.gridData[0]\n        if (gridTable.rows && Array.isArray(gridTable.rows)) {\n          flattenedData = gridTable.rows.map((row: any) => {\n            const obj: any = {}\n            if (row.columns && Array.isArray(row.columns)) {\n              row.columns.forEach((col: any) => {\n                if (col.columnInfo && col.columnInfo.columnName) {\n                  obj[col.columnInfo.columnName] = col.value\n                }\n              })\n            }\n            return obj as T\n          })\n        }\n      }\n\n      return {\n        data: flattenedData,\n        success: true,\n      }\n    } catch (error: any) {\n      return {\n        data: [],\n        success: false,\n        errorMessage: error.message,\n        errorType: error.code,\n      }\n    }\n  }\n\n  /**\n   * Helper to create DataService parameters\n   *\n   * @example\n   * ```typescript\n   * const params = sdk.dataService.createParameters([\n   *   { name: 'customerId', value: 'ALFKI' },\n   *   { name: 'year', value: 2024 }\n   * ])\n   * ```\n   */\n  createParameters(params: Array<{ name: string; value: any; isGroupBy?: boolean }>): IDataServiceParameter[] {\n    return params.map(p => ({\n      name: p.name,\n      value: p.value,\n      isGroupBy: p.isGroupBy ?? false,\n    }))\n  }\n\n  /**\n   * Execute multiple DataService queries in parallel\n   *\n   * @example\n   * ```typescript\n   * const [rejectionTypes, statusList] = await sdk.dataService.executeMany([\n   *   { id: 42, parameters: [] },\n   *   { id: 43, parameters: [] }\n   * ], token)\n   * ```\n   */\n  async executeMany<T = any>(\n    requests: IDataServiceRequest[],\n    token: string\n  ): Promise<IDataServiceResponse<T>[]> {\n    const promises = requests.map(request => this.execute<T>(request, token))\n    return Promise.all(promises)\n  }\n\n  /**\n   * Get all DataServices for a specific tab module (page)\n   *\n   * @example\n   * ```typescript\n   * const dataServices = await sdk.dataService.getByTabModuleId(1018, token)\n   * console.log(dataServices) // Array of IDataServiceMetadata\n   *\n   * // Find by name\n   * const rejectionDS = dataServices.find(ds => ds.name === 'Motivos de Rechazo')\n   * if (rejectionDS) {\n   *   const result = await sdk.dataService.execute({ id: rejectionDS.id }, token)\n   * }\n   * ```\n   */\n  async getByTabModuleId(\n    tabModuleId: number,\n    token: string\n  ): Promise<IDataServiceMetadata[]> {\n    try {\n      const response = await this.client.get<any>(\n        `${this.apiUrl}/Dashboard/DataService/GetByTabModuleId?tabModuleId=${tabModuleId}`,\n        {\n          headers: {\n            'Authorization': `Basic ${token}`,\n          },\n        }\n      )\n\n      // API returns: { id, tabModuleID, configuration: { grid: [...] } }\n      // Extract grid items and convert to IDataServiceMetadata\n      if (response && response.configuration && Array.isArray(response.configuration.grid)) {\n        return response.configuration.grid.map((item: any) => ({\n          id: item.id,\n          name: item.title, // 'title' is the DataService name\n          tabModuleId: response.tabModuleID,\n          uniqueId: item.uniqueId,\n          cacheTime: item.cacheTime,\n          isGlobalParams: item.isGlobalParams,\n          isActive: true, // Assume active if in grid\n        }))\n      }\n\n      return []\n    } catch (error: any) {\n      console.error('Error fetching DataServices by tabModuleId:', error)\n      return []\n    }\n  }\n\n  /**\n   * Execute a DataService by name (instead of ID)\n   * Automatically finds the DataService ID from the tab module and executes it\n   *\n   * @example\n   * ```typescript\n   * // Developer only needs to know:\n   * // 1. Tab module ID (page ID) - stable across environments\n   * // 2. DataService name - descriptive, human-readable\n   *\n   * const result = await sdk.dataService.executeByName<RejectionType>({\n   *   tabModuleId: 1018,\n   *   dataServiceName: 'Motivos de Rechazo',\n   *   parameters: [\n   *     { name: 'status', value: 'active' }\n   *   ]\n   * }, token)\n   *\n   * if (result.success) {\n   *   console.log(result.data) // RejectionType[]\n   * }\n   * ```\n   */\n  async executeByName<T = any>(\n    request: IDataServiceExecuteByNameRequest,\n    token: string\n  ): Promise<IDataServiceResponse<T>> {\n    const { tabModuleId, dataServiceName, parameters = [], withoutCache = false, executeFromGlobal = false } = request\n\n    try {\n      // 1. Get all DataServices for this tab module\n      const dataServices = await this.getByTabModuleId(tabModuleId, token)\n\n      // 2. Find the DataService by name\n      const dataService = dataServices.find(ds => ds.name === dataServiceName)\n\n      if (!dataService) {\n        return {\n          data: [],\n          success: false,\n          errorMessage: `DataService '${dataServiceName}' not found in tab module ${tabModuleId}`,\n          errorType: 'DS_NOT_FOUND',\n        }\n      }\n\n      // 3. Execute the DataService using its ID\n      return await this.execute<T>({\n        id: dataService.id,\n        parameters,\n        withoutCache,\n        executeFromGlobal,\n      }, token)\n\n    } catch (error: any) {\n      return {\n        data: [],\n        success: false,\n        errorMessage: error.message,\n        errorType: error.code,\n      }\n    }\n  }\n\n  /**\n   * Find a DataService by name in a tab module\n   * Returns the DataService metadata without executing it\n   *\n   * @example\n   * ```typescript\n   * const dataService = await sdk.dataService.findByName(1018, 'Motivos de Rechazo', token)\n   *\n   * if (dataService) {\n   *   console.log(`Found DataService ID: ${dataService.id}`)\n   *   // Can now execute it multiple times without re-fetching metadata\n   *   const result = await sdk.dataService.execute({ id: dataService.id }, token)\n   * }\n   * ```\n   */\n  async findByName(\n    tabModuleId: number,\n    dataServiceName: string,\n    token: string\n  ): Promise<IDataServiceMetadata | null> {\n    const dataServices = await this.getByTabModuleId(tabModuleId, token)\n    return dataServices.find(ds => ds.name === dataServiceName) || null\n  }\n\n  /**\n   * Get all pages from Dashboard\n   *\n   * @example\n   * ```typescript\n   * const pages = await sdk.dataService.getPages(token)\n   * console.log(pages.map(p => p.tabName)) // ['Facturas', 'Clientes', 'Productos', ...]\n   *\n   * // Find page by name\n   * const facturasPage = pages.find(p => p.tabName === 'Facturas')\n   * if (facturasPage) {\n   *   const dataServices = await sdk.dataService.getByTabModuleId(facturasPage.tabId, token)\n   * }\n   * ```\n   */\n  async getPages(token: string): Promise<IPageMetadata[]> {\n    try {\n      const response = await this.client.get<IPageMetadata[]>(\n        `${this.apiUrl}/Pages`,\n        {\n          headers: {\n            'bz-auth-token': `Basic ${token}`,\n          },\n        }\n      )\n\n      return response || []\n    } catch (error: any) {\n      console.error('Error fetching pages:', error)\n      return []\n    }\n  }\n\n  /**\n   * Find a page by name (searches recursively in children)\n   *\n   * @example\n   * ```typescript\n   * const page = await sdk.dataService.findPageByName('Facturas', token)\n   *\n   * if (page) {\n   *   console.log(`Page ID: ${page.tabId}`)\n   *   // Can now get DataServices for this page\n   *   const dataServices = await sdk.dataService.getByTabModuleId(page.tabId, token)\n   * }\n   * ```\n   */\n  async findPageByName(\n    pageName: string,\n    token: string\n  ): Promise<IPageMetadata | null> {\n    const pages = await this.getPages(token)\n\n    // Helper function to search recursively\n    const searchInPages = (pageList: IPageMetadata[]): IPageMetadata | null => {\n      for (const page of pageList) {\n        // Check current page\n        if (page.tabName === pageName) {\n          return page\n        }\n\n        // Search in children if they exist\n        if (page.children && Array.isArray(page.children) && page.children.length > 0) {\n          const found = searchInPages(page.children)\n          if (found) {\n            return found\n          }\n        }\n      }\n      return null\n    }\n\n    return searchInPages(pages)\n  }\n\n  /**\n   * Execute DataService by page name + DataService name\n   * BEST DEVELOPER EXPERIENCE - No numeric IDs needed at all!\n   *\n   * SECURITY BENEFIT: getPages() only returns pages the user has access to,\n   * providing an automatic security layer. If the user doesn't have access\n   * to the page, this method returns PAGE_NOT_FOUND error.\n   *\n   * @example\n   * ```typescript\n   * // Developer only needs two descriptive names:\n   * // 1. Page name (e.g., 'Facturas')\n   * // 2. DataService name (e.g., 'Motivos de Rechazo')\n   *\n   * const result = await sdk.dataService.executeByPageAndName<RejectionType>({\n   *   pageName: 'Facturas',\n   *   dataServiceName: 'Motivos de Rechazo',\n   *   parameters: [\n   *     { name: 'status', value: 'active' }\n   *   ]\n   * }, token)\n   *\n   * if (result.success) {\n   *   console.log(result.data) // RejectionType[]\n   * } else if (result.errorType === 'PAGE_NOT_FOUND') {\n   *   console.log('User does not have access to this page')\n   * }\n   * ```\n   */\n  async executeByPageAndName<T = any>(\n    request: IDataServiceExecuteByPageAndNameRequest,\n    token: string\n  ): Promise<IDataServiceResponse<T>> {\n    const { pageName, dataServiceName, parameters = [], withoutCache = false, executeFromGlobal = false } = request\n\n    try {\n      // 1. Find page by name\n      const page = await this.findPageByName(pageName, token)\n\n      if (!page) {\n        return {\n          data: [],\n          success: false,\n          errorMessage: `Page '${pageName}' not found`,\n          errorType: 'PAGE_NOT_FOUND',\n        }\n      }\n\n      // 2. Extract tabModuleID from modules array\n      let tabModuleId: number | null = null\n\n      // Navigate: page.modules[].modules[].tabModuleID\n      if (page.modules && Array.isArray(page.modules)) {\n        for (const moduleRow of page.modules) {\n          if (moduleRow.modules && Array.isArray(moduleRow.modules)) {\n            for (const module of moduleRow.modules) {\n              if (module.tabModuleID) {\n                tabModuleId = module.tabModuleID\n                break\n              }\n            }\n            if (tabModuleId) break\n          }\n        }\n      }\n\n      if (!tabModuleId) {\n        return {\n          data: [],\n          success: false,\n          errorMessage: `No modules found for page '${pageName}'`,\n          errorType: 'NO_MODULES_FOUND',\n        }\n      }\n\n      // 3. Execute DataService by name using the module ID\n      return await this.executeByName<T>({\n        tabModuleId,\n        dataServiceName,\n        parameters,\n        withoutCache,\n        executeFromGlobal,\n      }, token)\n\n    } catch (error: any) {\n      return {\n        data: [],\n        success: false,\n        errorMessage: error.message,\n        errorType: error.code,\n      }\n    }\n  }\n}\n","/**\n * BizuitTaskService\n *\n * Service for managing user task lists based on Bizuit BPM permissions.\n * Provides methods to:\n * - Get all processes available to user\n * - Get specific process details\n * - Search for task instances with pagination\n */\n\nimport { BizuitHttpClient } from './http-client'\nimport type { IBizuitConfig } from '../types'\nimport type {\n  IProcessMetadata,\n  ITasksSearchRequest,\n  ITasksSearchResponse,\n} from '../types/tasks.types'\n\nexport class BizuitTaskService {\n  private client: BizuitHttpClient\n  private apiUrl: string\n\n  constructor(config: IBizuitConfig) {\n    this.client = new BizuitHttpClient(config)\n    this.apiUrl = config.apiUrl\n  }\n\n  /**\n   * Get all processes available to the authenticated user\n   *\n   * @param token - Authorization token (Basic or Bearer)\n   * @returns Array of process metadata with activities\n   *\n   * @example\n   * ```typescript\n   * const sdk = new BizuitSDK({ apiUrl: 'https://api.example.com' })\n   * const processes = await sdk.tasks.getProcesses(authToken)\n   *\n   * processes.forEach(process => {\n   *   console.log(process.workflowDisplayName)\n   *   console.log('Start points:', process.activities.filter(a => a.isStartPoint))\n   *   console.log('Activities:', process.activities.filter(a => !a.isStartPoint))\n   * })\n   * ```\n   */\n  async getProcesses(token: string): Promise<IProcessMetadata[]> {\n    const headers: Record<string, string> = {\n      Authorization: token,\n    }\n\n    const result = await this.client.get<IProcessMetadata[]>(\n      `${this.apiUrl}/Processes?isMobile=false`,\n      { headers }\n    )\n\n    return result\n  }\n\n  /**\n   * Get detailed information for a specific process\n   *\n   * @param processName - Process name (eventName)\n   * @param token - Authorization token (Basic or Bearer)\n   * @returns Single process metadata with detailed activity information\n   *\n   * @example\n   * ```typescript\n   * const sdk = new BizuitSDK({ apiUrl: 'https://api.example.com' })\n   * const processDetails = await sdk.tasks.getProcessDetails('TestWix', authToken)\n   *\n   * console.log('Process:', processDetails.workflowDisplayName)\n   * console.log('Activities:', processDetails.activities.length)\n   *\n   * const startPoint = processDetails.activities.find(a => a.isStartPoint)\n   * if (startPoint) {\n   *   console.log('Start point:', startPoint.displayName)\n   *   console.log('Form ID:', startPoint.formId)\n   * }\n   * ```\n   */\n  async getProcessDetails(\n    processName: string,\n    token: string\n  ): Promise<IProcessMetadata | null> {\n    const headers: Record<string, string> = {\n      Authorization: token,\n    }\n\n    const result = await this.client.get<IProcessMetadata[]>(\n      `${this.apiUrl}/Processes?eventName=${encodeURIComponent(processName)}&isMobile=false`,\n      { headers }\n    )\n\n    // API returns array with single item when querying by eventName\n    return result && result.length > 0 ? result[0] : null\n  }\n\n  /**\n   * Search for task instances with optional pagination\n   *\n   * @param request - Search parameters including process, activity, and pagination\n   * @param token - Authorization token (Basic or Bearer)\n   * @returns Search response with events, instances, and total count\n   *\n   * @example\n   * ```typescript\n   * const sdk = new BizuitSDK({ apiUrl: 'https://api.example.com' })\n   *\n   * // Basic search\n   * const result = await sdk.tasks.searchTasks({\n   *   ProcessName: 'TestWix',\n   *   ActivityName: 'userInteractionActivity1'\n   * }, authToken)\n   *\n   * console.log('Total instances:', result.instancesTotalCount[0]?.count)\n   * console.log('Instances:', result.instances.length)\n   *\n   * // Search with pagination\n   * const pagedResult = await sdk.tasks.searchTasks({\n   *   ProcessName: 'TestWix',\n   *   ActivityName: 'userInteractionActivity1',\n   *   pageNumber: 1,\n   *   pageSize: 20,\n   *   DateFrom: '2025-01-01',\n   *   DateTo: '2025-12-31',\n   *   LockedState: -1  // -1 = all, 0 = unlocked, 1 = locked\n   * }, authToken)\n   *\n   * // Access instance details\n   * pagedResult.instances.forEach(instance => {\n   *   console.log('Instance ID:', instance.instanceId)\n   *   console.log('Status:', instance.locked ? 'Locked' : 'Available')\n   *   console.log('Locked by:', instance.lockedBy)\n   *\n   *   // Access dynamic columns with user-friendly names (automatically flattened by SDK)\n   *   console.log('Cliente:', instance['CLIENTE'])\n   *   console.log('Descripción:', instance['Descripción'])\n   *   console.log('Versión:', instance['Versión'])\n   *   console.log('Usuario:', instance['Último ejecutado por'])\n   *   console.log('Fecha:', instance['Fecha Ejecución'])\n   *   console.log('Tiempo:', instance['Tiempo Transcurrido'])\n   * })\n   * ```\n   */\n  async searchTasks(\n    request: ITasksSearchRequest,\n    token: string\n  ): Promise<ITasksSearchResponse> {\n    const headers: Record<string, string> = {\n      Authorization: token,\n    }\n\n    // Add pagination headers if provided\n    if (request.pageNumber !== undefined) {\n      headers['bz-page'] = String(request.pageNumber)\n    }\n    if (request.pageSize !== undefined) {\n      headers['bz-page-size'] = String(request.pageSize)\n    }\n\n    // Build request body (exclude pagination params)\n    const { pageNumber, pageSize, ...bodyParams } = request\n\n    // Set defaults for required fields if not provided\n    const requestBody = {\n      DateFrom: '1900-01-01',\n      DateTo: '2100-01-01',\n      LockedState: -1,\n      SerializedFilters: '',\n      IncludeWarnings: true,\n      ChildProcessName: '',\n      IsMobile: false,\n      Parameters: [],\n      ...bodyParams,\n    }\n\n    const result = await this.client.post<ITasksSearchResponse>(\n      `${this.apiUrl}/Instances/Search`,\n      requestBody,\n      { headers }\n    )\n\n    // Transform instances to flatten columnDefinitionValues\n    return this.transformSearchResponse(result)\n  }\n\n  /**\n   * Transform search response to flatten column definition values\n   * Converts columnDefinitionValues array into direct properties on the instance\n   * using headerText as property names for user-friendly access\n   * and removes the original array for a completely flat structure\n   *\n   * @private\n   */\n  private transformSearchResponse(response: ITasksSearchResponse): ITasksSearchResponse {\n    // Build a map of columnName -> headerText from events metadata\n    const columnHeaderMap = new Map<string, string>()\n\n    response.events.forEach((event) => {\n      event.activities.forEach((activity) => {\n        activity.columnsDefinitions.forEach((colDef) => {\n          columnHeaderMap.set(colDef.name, colDef.headerText)\n        })\n      })\n    })\n\n    return {\n      ...response,\n      instances: response.instances.map((instance) => {\n        // Create flattened object with all dynamic columns as direct properties\n        const flatInstance: any = { ...instance }\n\n        // Add each column as a direct property using headerText as key\n        instance.columnDefinitionValues.forEach((col) => {\n          const headerText = columnHeaderMap.get(col.columnName) || col.columnName\n          flatInstance[headerText] = col.value\n        })\n\n        // Remove redundant properties\n        delete flatInstance.columnDefinitionValues\n        delete flatInstance.eventName\n        delete flatInstance.activityName\n        delete flatInstance.instanceDescription\n\n        return flatInstance\n      }),\n    }\n  }\n\n  /**\n   * Get task count for a specific process and activity\n   *\n   * @param processName - Process name\n   * @param activityName - Activity name\n   * @param token - Authorization token\n   * @returns Total count of instances\n   *\n   * @example\n   * ```typescript\n   * const count = await sdk.tasks.getTaskCount('TestWix', 'userInteractionActivity1', token)\n   * console.log(`Total tasks: ${count}`)\n   * ```\n   */\n  async getTaskCount(\n    processName: string,\n    activityName: string,\n    token: string\n  ): Promise<number> {\n    const result = await this.searchTasks(\n      {\n        ProcessName: processName,\n        ActivityName: activityName,\n        pageSize: 1, // Minimal page size to get count only\n      },\n      token\n    )\n\n    const countData = result.instancesTotalCount.find(\n      (item) => item.eventName === processName\n    )\n\n    return countData ? countData.count : 0\n  }\n\n  /**\n   * Get all start points across all processes\n   *\n   * @param token - Authorization token\n   * @returns Array of activities that are start points\n   *\n   * @example\n   * ```typescript\n   * const startPoints = await sdk.tasks.getStartPoints(token)\n   *\n   * startPoints.forEach(sp => {\n   *   console.log('Process:', sp.processName)\n   *   console.log('Start point:', sp.displayName)\n   *   console.log('Form ID:', sp.formId)\n   * })\n   * ```\n   */\n  async getStartPoints(token: string) {\n    const processes = await this.getProcesses(token)\n\n    const startPoints = processes.flatMap((process) =>\n      process.activities\n        .filter((activity) => activity.isStartPoint)\n        .map((activity) => ({\n          processName: process.name,\n          processDisplayName: process.workflowDisplayName,\n          ...activity,\n        }))\n    )\n\n    return startPoints\n  }\n\n  /**\n   * Get all activities (non-start points) across all processes\n   *\n   * @param token - Authorization token\n   * @returns Array of activities that are not start points\n   *\n   * @example\n   * ```typescript\n   * const activities = await sdk.tasks.getActivities(token)\n   *\n   * activities.forEach(activity => {\n   *   console.log('Process:', activity.processName)\n   *   console.log('Activity:', activity.displayName)\n   * })\n   * ```\n   */\n  async getActivities(token: string) {\n    const processes = await this.getProcesses(token)\n\n    const activities = processes.flatMap((process) =>\n      process.activities\n        .filter((activity) => !activity.isStartPoint)\n        .map((activity) => ({\n          processName: process.name,\n          processDisplayName: process.workflowDisplayName,\n          ...activity,\n        }))\n    )\n\n    return activities\n  }\n}\n","/**\n * Bizuit SDK - Main entry point\n * Provides unified access to all Bizuit services\n */\n\nimport { BizuitAuthService } from './auth-service'\nimport { BizuitProcessService } from './process-service'\nimport { BizuitInstanceLockService } from './instance-lock-service'\nimport { BizuitFormService } from './form-service'\nimport { BizuitDataServiceService } from './dataservice-service'\nimport { BizuitTaskService } from './task-service'\nimport type { IBizuitConfig } from '../types'\n\nexport class BizuitSDK {\n  public auth: BizuitAuthService\n  public process: BizuitProcessService\n  public instanceLock: BizuitInstanceLockService\n  public forms: BizuitFormService\n  public dataService: BizuitDataServiceService\n  public tasks: BizuitTaskService\n\n  private config: IBizuitConfig\n\n  constructor(config: IBizuitConfig) {\n    this.config = config\n    this.auth = new BizuitAuthService(config)\n    this.process = new BizuitProcessService(config)\n    this.instanceLock = new BizuitInstanceLockService(config)\n    this.forms = new BizuitFormService(this)\n    this.dataService = new BizuitDataServiceService(config)\n    this.tasks = new BizuitTaskService(config)\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): IBizuitConfig {\n    return { ...this.config }\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<IBizuitConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n\n    // Recreate services with new config\n    this.auth = new BizuitAuthService(this.config)\n    this.process = new BizuitProcessService(this.config)\n    this.instanceLock = new BizuitInstanceLockService(this.config)\n    this.forms = new BizuitFormService(this)\n    this.dataService = new BizuitDataServiceService(this.config)\n    this.tasks = new BizuitTaskService(this.config)\n  }\n}\n\n/**\n * Factory function to create SDK instance\n */\nexport function createBizuitSDK(config: IBizuitConfig): BizuitSDK {\n  return new BizuitSDK(config)\n}\n","/**\n * Parameter Parser Utilities\n * Handles complex parameter structures (JSON, XML, nested objects)\n */\n\nimport type { IParameter } from '../types'\n\nexport class ParameterParser {\n  /**\n   * Parse complex parameter value from JSON string\n   */\n  static parseComplexValue(parameter: IParameter): any {\n    if (!parameter.valueJson) {\n      return parameter.value\n    }\n\n    try {\n      return JSON.parse(parameter.valueJson)\n    } catch (error) {\n      console.warn('[ParameterParser] Failed to parse valueJson:', error)\n      return parameter.value\n    }\n  }\n\n  /**\n   * Serialize complex value to parameter format\n   */\n  static serializeComplexValue(value: any, type: 'SingleValue' | 'Xml' | 'ComplexObject'): { value: string; valueJson?: string } {\n    if (type === 'SingleValue') {\n      return {\n        value: String(value ?? ''),\n      }\n    }\n\n    if (typeof value === 'object') {\n      const jsonString = JSON.stringify(value)\n      return {\n        value: jsonString,\n        valueJson: jsonString,\n      }\n    }\n\n    return {\n      value: String(value ?? ''),\n      valueJson: String(value ?? ''),\n    }\n  }\n\n  /**\n   * Get value from nested path (e.g., \"customer.address.street\")\n   */\n  static getNestedValue(obj: any, path: string): any {\n    if (!path) return obj\n\n    const parts = path.split(/[./]/)\n    let current = obj\n\n    for (const part of parts) {\n      if (current === null || current === undefined) {\n        return undefined\n      }\n      current = current[part]\n    }\n\n    return current\n  }\n\n  /**\n   * Set value at nested path\n   */\n  static setNestedValue(obj: any, path: string, value: any): any {\n    if (!path) return value\n\n    const parts = path.split(/[./]/)\n    const last = parts.pop()!\n    let current = obj\n\n    for (const part of parts) {\n      if (!current[part]) {\n        current[part] = {}\n      }\n      current = current[part]\n    }\n\n    current[last] = value\n    return obj\n  }\n\n  /**\n   * Flatten parameters for form data\n   */\n  static flattenParameters(parameters: IParameter[]): Record<string, any> {\n    const flattened: Record<string, any> = {}\n\n    parameters.forEach((param) => {\n      if (param.type === 'SingleValue') {\n        flattened[param.name] = param.value\n      } else {\n        flattened[param.name] = this.parseComplexValue(param)\n      }\n    })\n\n    return flattened\n  }\n\n  /**\n   * Unflatten form data back to parameters\n   */\n  static unflattenToParameters(\n    data: Record<string, any>,\n    originalParameters: IParameter[]\n  ): IParameter[] {\n    return originalParameters.map((param) => {\n      const value = data[param.name]\n\n      if (value === undefined) {\n        return param\n      }\n\n      const serialized = this.serializeComplexValue(value, param.type)\n\n      return {\n        ...param,\n        ...serialized,\n      }\n    })\n  }\n\n  /**\n   * Merge parameters with form values\n   */\n  static mergeWithFormData(\n    parameters: IParameter[],\n    formData: Record<string, any>\n  ): IParameter[] {\n    return parameters.map((param) => {\n      if (formData.hasOwnProperty(param.name)) {\n        const serialized = this.serializeComplexValue(formData[param.name], param.type)\n        return {\n          ...param,\n          ...serialized,\n          hasBinding: true,\n        }\n      }\n      return param\n    })\n  }\n\n  /**\n   * Filter parameters by direction\n   */\n  static filterByDirection(\n    parameters: IParameter[],\n    direction: 'In' | 'Out' | 'InOut'\n  ): IParameter[] {\n    return parameters.filter((p) => p.direction === direction || p.direction === 'InOut')\n  }\n\n  /**\n   * Get input parameters only\n   */\n  static getInputParameters(parameters: IParameter[]): IParameter[] {\n    return this.filterByDirection(parameters, 'In')\n  }\n\n  /**\n   * Get output parameters only\n   */\n  static getOutputParameters(parameters: IParameter[]): IParameter[] {\n    return this.filterByDirection(parameters, 'Out')\n  }\n\n  /**\n   * Validate required parameters\n   */\n  static validateRequired(\n    parameters: IParameter[],\n    formData: Record<string, any>\n  ): { valid: boolean; missing: string[] } {\n    const inputParams = this.getInputParameters(parameters)\n    const missing: string[] = []\n\n    inputParams.forEach((param) => {\n      if (!param.isSystemParameter) {\n        const value = formData[param.name]\n        if (value === undefined || value === null || value === '') {\n          missing.push(param.name)\n        }\n      }\n    })\n\n    return {\n      valid: missing.length === 0,\n      missing,\n    }\n  }\n}\n","/**\n * Error Handler Utilities\n */\n\nimport type { IApiError } from '../types'\n\nexport class BizuitError extends Error {\n  code?: string\n  statusCode?: number\n  details?: unknown\n\n  constructor(message: string, code?: string, statusCode?: number, details?: unknown) {\n    super(message)\n    this.name = 'BizuitError'\n    this.code = code\n    this.statusCode = statusCode\n    this.details = details\n  }\n\n  static fromApiError(apiError: IApiError): BizuitError {\n    return new BizuitError(\n      apiError.message,\n      apiError.code,\n      apiError.statusCode,\n      apiError.details\n    )\n  }\n\n  isAuthError(): boolean {\n    return this.statusCode === 401 || this.code === 'UNAUTHORIZED'\n  }\n\n  isNetworkError(): boolean {\n    return this.code === 'NETWORK_ERROR'\n  }\n\n  isValidationError(): boolean {\n    return this.statusCode === 400 || this.code === 'VALIDATION_ERROR'\n  }\n}\n\nexport function handleError(error: unknown): BizuitError {\n  if (error instanceof BizuitError) {\n    return error\n  }\n\n  if (error instanceof Error) {\n    return new BizuitError(error.message)\n  }\n\n  if (typeof error === 'object' && error !== null) {\n    const apiError = error as IApiError\n    if (apiError.message) {\n      return BizuitError.fromApiError(apiError)\n    }\n  }\n\n  return new BizuitError('An unknown error occurred')\n}\n","import type { ILoginResponse } from '../types/auth.types'\n\n/**\n * Parse URL parameters that come from Bizuit BPM with &amp; HTML encoding\n *\n * When Bizuit generates URLs in HTML context, browsers URL-encode &amp; as &amp%3B\n * This breaks standard query parameter parsing since \"amp;\" becomes part of param name\n *\n * @param paramName - The parameter name to extract\n * @param searchParams - URLSearchParams object from useSearchParams()\n * @returns The parameter value or null if not found\n *\n * @example\n * ```tsx\n * const searchParams = useSearchParams()\n * const token = parseBizuitUrlParam('token', searchParams)\n * const eventName = parseBizuitUrlParam('eventName', searchParams)\n * ```\n */\nexport function parseBizuitUrlParam(paramName: string, searchParams: URLSearchParams): string | null {\n  // Try standard parsing first\n  const standardValue = searchParams.get(paramName)\n  if (standardValue) {\n    return standardValue\n  }\n\n  // If standard parsing fails, manually parse query string\n  // This handles cases where &amp; was URL-encoded to &amp%3B\n  if (typeof window !== 'undefined') {\n    const rawUrl = window.location.href\n\n    // Extract query string after ?\n    const queryStartIndex = rawUrl.indexOf('?')\n    if (queryStartIndex === -1) {\n      return null\n    }\n\n    let queryString = rawUrl.substring(queryStartIndex + 1)\n\n    // Clean up the query string:\n    // 1. Replace &amp%3B with & (URL-encoded &amp;)\n    // 2. Replace &amp; with & (HTML entity)\n    // 3. Replace %3B with nothing (leftover semicolons)\n    queryString = queryString\n      .replace(/&amp%3B/gi, '&')\n      .replace(/&amp;/gi, '&')\n      .replace(/%3B/gi, '')\n\n    // Parse manually\n    const params = new URLSearchParams(queryString)\n    return params.get(paramName)\n  }\n\n  return null\n}\n\n/**\n * Create an ILoginResponse object from a URL token\n *\n * This is useful when receiving authentication tokens from Bizuit BPM URLs.\n * The token will be prefixed with \"Basic \" if not already present.\n *\n * @param urlToken - The token from the URL (without \"Basic \" prefix)\n * @param userName - Optional username (defaults to 'bizuit-user')\n * @param expirationMinutes - Token expiration in minutes (defaults to 1440 = 24 hours)\n * @returns ILoginResponse object ready to use with setAuthData()\n *\n * @example\n * ```tsx\n * const urlToken = searchParams.get('token')\n * const userName = searchParams.get('UserName')\n *\n * if (urlToken) {\n *   const authData = createAuthFromUrlToken(urlToken, userName, 120) // 2 hours\n *   setAuthData(authData)\n * }\n * ```\n */\nexport function createAuthFromUrlToken(\n  urlToken: string,\n  userName?: string,\n  expirationMinutes: number = 1440\n): ILoginResponse {\n  // Add \"Basic \" prefix if not already present\n  const tokenWithPrefix = urlToken.startsWith('Basic ') ? urlToken : `Basic ${urlToken}`\n\n  const expirationMs = expirationMinutes * 60 * 1000\n\n  return {\n    Token: tokenWithPrefix,\n    User: {\n      Username: userName || 'bizuit-user',\n      UserID: 0,\n      DisplayName: userName || 'Usuario Bizuit',\n    },\n    ExpirationDate: new Date(Date.now() + expirationMs).toISOString(),\n  }\n}\n\n/**\n * Build a login redirect URL with return path\n *\n * @param returnPath - The path to redirect to after login (e.g., '/start-process')\n * @param params - Optional additional query parameters to include in the return URL\n * @returns Complete login URL with redirect parameter\n *\n * @example\n * ```tsx\n * // Simple redirect\n * const loginUrl = buildLoginRedirectUrl('/start-process')\n * // \"/login?redirect=%2Fstart-process\"\n *\n * // With additional parameters\n * const loginUrl = buildLoginRedirectUrl('/start-process', { eventName: 'MyEvent' })\n * // \"/login?redirect=%2Fstart-process%3FeventName%3DMyEvent\"\n * ```\n */\nexport function buildLoginRedirectUrl(returnPath: string, params?: Record<string, string>): string {\n  // Build return URL with optional parameters\n  let returnUrl = returnPath\n\n  if (params && Object.keys(params).length > 0) {\n    const queryParams = new URLSearchParams(params)\n    returnUrl = `${returnPath}?${queryParams.toString()}`\n  }\n\n  // Build login URL with redirect parameter\n  const loginParams = new URLSearchParams()\n  loginParams.set('redirect', returnUrl)\n\n  return `/login?${loginParams.toString()}`\n}\n","/**\n * Context type for error formatting\n */\nexport type ErrorContext = 'load' | 'submit' | 'lock' | 'start' | 'general'\n\n/**\n * Convert API errors to user-friendly messages\n *\n * Handles common HTTP status codes and network errors to provide\n * helpful feedback to users instead of technical error messages.\n *\n * @param error - The error object from API call\n * @param context - The context where the error occurred\n * @returns User-friendly error message in Spanish\n *\n * @example\n * ```tsx\n * try {\n *   await sdk.process.raiseEvent(...)\n * } catch (err) {\n *   const message = formatBizuitError(err, 'start')\n *   setError(message)\n * }\n * ```\n */\nexport function formatBizuitError(error: any, context: ErrorContext = 'general'): string {\n  // Check status code\n  const statusCode = error?.statusCode || error?.status || error?.response?.status\n\n  // 401 errors - Unauthorized\n  // Note: These should be handled automatically by useBizuitSDKWithAuth\n  if (statusCode === 401) {\n    return 'Su sesión ha expirado. Redirigiendo a login...'\n  }\n\n  // 404 errors - Not Found\n  if (statusCode === 404) {\n    if (context === 'load') {\n      return 'No se encontró la instancia del proceso. Verifique que el ID sea correcto.'\n    }\n    if (context === 'start') {\n      return 'El proceso no existe o no tiene parámetros definidos. Verifique el nombre del proceso.'\n    }\n    return 'No se encontró el recurso solicitado. Verifique los datos ingresados.'\n  }\n\n  // 400 errors - Bad Request (usually validation errors)\n  if (statusCode === 400) {\n    // Check for specific validation messages in error\n    const message = error?.message || error?.errorMessage || ''\n\n    if (message.toLowerCase().includes('format') || message.toLowerCase().includes('formato')) {\n      return 'El formato del ID de instancia es incorrecto. Debe ser un GUID válido (ejemplo: 550e8400-e29b-41d4-a716-446655440000).'\n    }\n\n    if (message.toLowerCase().includes('required') || message.toLowerCase().includes('requerido')) {\n      return 'Faltan datos requeridos. Verifique que todos los campos obligatorios estén completos.'\n    }\n\n    return 'Los datos enviados no son válidos. Verifique la información e intente nuevamente.'\n  }\n\n  // 403 errors - Forbidden\n  if (statusCode === 403) {\n    return 'No tiene permisos para realizar esta operación.'\n  }\n\n  // 409 errors - Conflict (instance locked by another user)\n  if (statusCode === 409) {\n    return 'La instancia está bloqueada por otro usuario. Intente nuevamente más tarde.'\n  }\n\n  // 500 errors - Server Error\n  if (statusCode === 500 || statusCode >= 500) {\n    return 'Error en el servidor. Por favor intente nuevamente o contacte al administrador.'\n  }\n\n  // Network errors\n  if (\n    error?.code === 'ECONNREFUSED' ||\n    error?.code === 'ERR_NETWORK' ||\n    error?.message?.includes('fetch failed') ||\n    error?.message?.includes('Network')\n  ) {\n    return 'No se pudo conectar al servidor. Verifique su conexión a internet.'\n  }\n\n  // Timeout errors\n  if (error?.code === 'ETIMEDOUT' || error?.message?.includes('timeout')) {\n    return 'La operación tardó demasiado tiempo. Verifique su conexión e intente nuevamente.'\n  }\n\n  // If we have a user-friendly message from the API, use it\n  if (error?.errorMessage && typeof error.errorMessage === 'string' && error.errorMessage.length < 200) {\n    return error.errorMessage\n  }\n\n  if (error?.message && typeof error.message === 'string' && error.message.length < 200) {\n    // Don't show very technical messages\n    if (\n      !error.message.includes('undefined') &&\n      !error.message.includes('null') &&\n      !error.message.includes('Cannot read') &&\n      !error.message.includes('is not')\n    ) {\n      return error.message\n    }\n  }\n\n  // Default messages by context\n  if (context === 'load') {\n    return 'Error al cargar los datos de la instancia. Por favor intente nuevamente.'\n  }\n  if (context === 'submit') {\n    return 'Error al guardar los cambios. Por favor intente nuevamente.'\n  }\n  if (context === 'lock') {\n    return 'Error al bloquear la instancia. Por favor intente nuevamente.'\n  }\n  if (context === 'start') {\n    return 'Error al iniciar el proceso. Por favor intente nuevamente.'\n  }\n\n  return 'Ocurrió un error inesperado. Por favor intente nuevamente.'\n}\n","/**\n * useBizuitSDK Hook\n * Provides access to Bizuit SDK instance via Context\n */\n\nimport { createContext, useContext, ReactNode } from 'react'\nimport { BizuitSDK } from '../api'\nimport type { IBizuitConfig } from '../types'\n\nconst BizuitSDKContext = createContext<BizuitSDK | null>(null)\n\nexport interface BizuitSDKProviderProps {\n  config: IBizuitConfig\n  children: ReactNode\n}\n\nexport function BizuitSDKProvider({ config, children }: BizuitSDKProviderProps) {\n  const sdk = new BizuitSDK(config)\n\n  return <BizuitSDKContext.Provider value={sdk}>{children}</BizuitSDKContext.Provider>\n}\n\nexport function useBizuitSDK(): BizuitSDK {\n  const context = useContext(BizuitSDKContext)\n\n  if (!context) {\n    throw new Error('useBizuitSDK must be used within BizuitSDKProvider')\n  }\n\n  return context\n}\n","/**\n * useAuth Hook\n * Manages authentication state and operations\n */\n\nimport { useState, useEffect, useCallback } from 'react'\nimport { useBizuitSDK } from './useBizuitSDK'\nimport type { IUserInfo, IRequestCheckFormAuth } from '../types'\n\nexport interface UseAuthOptions {\n  token?: string\n  userName?: string\n  autoValidate?: boolean\n}\n\nexport interface UseAuthReturn {\n  user: IUserInfo | null\n  isAuthenticated: boolean\n  isLoading: boolean\n  error: Error | null\n  validateToken: (token: string) => Promise<boolean>\n  checkFormAuth: (request: IRequestCheckFormAuth) => Promise<boolean>\n  getUserInfo: (token: string, userName: string) => Promise<IUserInfo | null>\n  checkPermissions: (requiredRoles: string[]) => Promise<boolean>\n  logout: () => void\n}\n\nexport function useAuth(options: UseAuthOptions = {}): UseAuthReturn {\n  const sdk = useBizuitSDK()\n  const [user, setUser] = useState<IUserInfo | null>(null)\n  const [isLoading, setIsLoading] = useState(options.autoValidate || false)\n  const [error, setError] = useState<Error | null>(null)\n\n  const validateToken = useCallback(\n    async (token: string): Promise<boolean> => {\n      setIsLoading(true)\n      setError(null)\n\n      try {\n        const userInfo = await sdk.auth.validateToken(token)\n\n        if (userInfo) {\n          setUser(userInfo)\n          return true\n        }\n\n        setUser(null)\n        return false\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Token validation failed')\n        setError(error)\n        setUser(null)\n        return false\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [sdk]\n  )\n\n  const checkFormAuth = useCallback(\n    async (request: IRequestCheckFormAuth): Promise<boolean> => {\n      setIsLoading(true)\n      setError(null)\n\n      try {\n        const response = await sdk.auth.checkFormAuth(request, options.token)\n\n        if (response.success && response.data?.username) {\n          // Set basic user info from auth check\n          setUser({\n            username: response.data.username,\n            roles: [],\n          })\n          return true\n        }\n\n        setError(new Error(response.errorMessage || 'Authentication failed'))\n        return false\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Form auth check failed')\n        setError(error)\n        return false\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [sdk, options.token]\n  )\n\n  const getUserInfo = useCallback(\n    async (token: string, userName: string) => {\n      setIsLoading(true)\n      setError(null)\n\n      try {\n        const userInfo = await sdk.auth.getUserInfo(token, userName)\n        setUser(userInfo)\n        return userInfo\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Failed to get user info')\n        setError(error)\n        return null\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [sdk]\n  )\n\n  const checkPermissions = useCallback(\n    async (requiredRoles: string[]): Promise<boolean> => {\n      if (!options.token || !options.userName) {\n        return false\n      }\n\n      try {\n        return await sdk.auth.checkPermissions(\n          options.token,\n          options.userName,\n          requiredRoles\n        )\n      } catch (err) {\n        console.error('Permission check failed:', err)\n        return false\n      }\n    },\n    [sdk, options.token, options.userName]\n  )\n\n  const logout = useCallback(() => {\n    setUser(null)\n    setError(null)\n  }, [])\n\n  // Auto-validate on mount if token provided\n  useEffect(() => {\n    if (options.autoValidate && options.token) {\n      validateToken(options.token)\n    }\n  }, []) // Run only once on mount\n\n  return {\n    user,\n    isAuthenticated: user !== null,\n    isLoading,\n    error,\n    validateToken,\n    checkFormAuth,\n    getUserInfo,\n    checkPermissions,\n    logout,\n  }\n}\n","/**\n * useTasks Hook\n *\n * React hook for managing task lists from Bizuit BPM.\n * Provides state management and methods for:\n * - Loading all processes\n * - Getting process details\n * - Searching task instances\n * - Loading/error states\n */\n\nimport { useState, useCallback, useEffect } from 'react'\nimport { useBizuitSDK } from './useBizuitSDK'\nimport type {\n  IProcessMetadata,\n  ITaskInstance,\n  ITasksSearchRequest,\n  ITasksSearchResponse,\n} from '../types/tasks.types'\n\nexport interface UseTasksOptions {\n  /** Authorization token (required) */\n  token: string\n  /** Auto-load processes on mount */\n  autoLoadProcesses?: boolean\n}\n\nexport interface UseTasksReturn {\n  /** All processes available to user */\n  processes: IProcessMetadata[] | null\n  /** Current task instances from search */\n  tasks: ITaskInstance[]\n  /** Full search response with metadata */\n  searchResponse: ITasksSearchResponse | null\n  /** Loading state */\n  isLoading: boolean\n  /** Error state */\n  error: Error | null\n  /** Load all processes */\n  getProcesses: () => Promise<void>\n  /** Load specific process details */\n  getProcessDetails: (processName: string) => Promise<IProcessMetadata | null>\n  /** Search for task instances */\n  searchTasks: (request: ITasksSearchRequest) => Promise<void>\n  /** Get task count without loading instances */\n  getTaskCount: (processName: string, activityName: string) => Promise<number>\n  /** Get all start points across processes */\n  getStartPoints: () => Promise<void>\n  /** Get all activities (non-start points) */\n  getActivities: () => Promise<void>\n  /** Clear error state */\n  clearError: () => void\n  /** Reset all state */\n  reset: () => void\n}\n\n/**\n * Hook for managing Bizuit task lists\n *\n * @param options - Configuration options\n * @returns Task state and methods\n *\n * @example\n * ```typescript\n * function TaskList() {\n *   const { tasks, isLoading, error, searchTasks } = useTasks({\n *     token: authToken,\n *     autoLoadProcesses: true\n *   })\n *\n *   useEffect(() => {\n *     searchTasks({\n *       ProcessName: 'TestWix',\n *       ActivityName: 'userInteractionActivity1',\n *       pageNumber: 1,\n *       pageSize: 20\n *     })\n *   }, [searchTasks])\n *\n *   if (isLoading) return <div>Loading...</div>\n *   if (error) return <div>Error: {error.message}</div>\n *\n *   return (\n *     <ul>\n *       {tasks.map(task => (\n *         <li key={task.instanceId}>\n *           {task.instanceDescription}\n *           {task.locked && <span> (Locked by {task.lockedBy})</span>}\n *         </li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n */\nexport function useTasks(options: UseTasksOptions): UseTasksReturn {\n  const sdk = useBizuitSDK()\n  const [processes, setProcesses] = useState<IProcessMetadata[] | null>(null)\n  const [tasks, setTasks] = useState<ITaskInstance[]>([])\n  const [searchResponse, setSearchResponse] = useState<ITasksSearchResponse | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<Error | null>(null)\n\n  /**\n   * Load all processes available to user\n   */\n  const getProcesses = useCallback(async () => {\n    setIsLoading(true)\n    setError(null)\n    try {\n      const result = await sdk.tasks.getProcesses(options.token)\n      setProcesses(result)\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to get processes')\n      setError(error)\n      throw error\n    } finally {\n      setIsLoading(false)\n    }\n  }, [sdk, options.token])\n\n  /**\n   * Load specific process details\n   */\n  const getProcessDetails = useCallback(\n    async (processName: string): Promise<IProcessMetadata | null> => {\n      setIsLoading(true)\n      setError(null)\n      try {\n        const result = await sdk.tasks.getProcessDetails(processName, options.token)\n        return result\n      } catch (err) {\n        const error =\n          err instanceof Error ? err : new Error(`Failed to get process details for ${processName}`)\n        setError(error)\n        throw error\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [sdk, options.token]\n  )\n\n  /**\n   * Search for task instances\n   */\n  const searchTasks = useCallback(\n    async (request: ITasksSearchRequest) => {\n      setIsLoading(true)\n      setError(null)\n      try {\n        const result = await sdk.tasks.searchTasks(request, options.token)\n        setSearchResponse(result)\n        setTasks(result.instances)\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Failed to search tasks')\n        setError(error)\n        setSearchResponse(null)\n        setTasks([])\n        throw error\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [sdk, options.token]\n  )\n\n  /**\n   * Get task count without loading instances\n   */\n  const getTaskCount = useCallback(\n    async (processName: string, activityName: string): Promise<number> => {\n      setIsLoading(true)\n      setError(null)\n      try {\n        const count = await sdk.tasks.getTaskCount(processName, activityName, options.token)\n        return count\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Failed to get task count')\n        setError(error)\n        throw error\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [sdk, options.token]\n  )\n\n  /**\n   * Get all start points across processes\n   */\n  const getStartPoints = useCallback(async () => {\n    setIsLoading(true)\n    setError(null)\n    try {\n      const result = await sdk.tasks.getStartPoints(options.token)\n      // Store as processes format for compatibility\n      setProcesses(\n        result.map((sp) => ({\n          name: sp.processName,\n          workflowDisplayName: sp.processDisplayName,\n          workflowName: sp.processName,\n          category: '',\n          subCategory: '',\n          icon: null,\n          iconColor: null,\n          activities: [sp],\n        }))\n      )\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to get start points')\n      setError(error)\n      throw error\n    } finally {\n      setIsLoading(false)\n    }\n  }, [sdk, options.token])\n\n  /**\n   * Get all activities (non-start points)\n   */\n  const getActivities = useCallback(async () => {\n    setIsLoading(true)\n    setError(null)\n    try {\n      const result = await sdk.tasks.getActivities(options.token)\n      // Store as processes format for compatibility\n      setProcesses(\n        result.map((activity) => ({\n          name: activity.processName,\n          workflowDisplayName: activity.processDisplayName,\n          workflowName: activity.processName,\n          category: '',\n          subCategory: '',\n          icon: null,\n          iconColor: null,\n          activities: [activity],\n        }))\n      )\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to get activities')\n      setError(error)\n      throw error\n    } finally {\n      setIsLoading(false)\n    }\n  }, [sdk, options.token])\n\n  /**\n   * Clear error state\n   */\n  const clearError = useCallback(() => {\n    setError(null)\n  }, [])\n\n  /**\n   * Reset all state\n   */\n  const reset = useCallback(() => {\n    setProcesses(null)\n    setTasks([])\n    setSearchResponse(null)\n    setError(null)\n    setIsLoading(false)\n  }, [])\n\n  /**\n   * Auto-load processes on mount if configured\n   */\n  useEffect(() => {\n    if (options.autoLoadProcesses) {\n      getProcesses()\n    }\n  }, [options.autoLoadProcesses, getProcesses])\n\n  return {\n    processes,\n    tasks,\n    searchResponse,\n    isLoading,\n    error,\n    getProcesses,\n    getProcessDetails,\n    searchTasks,\n    getTaskCount,\n    getStartPoints,\n    getActivities,\n    clearError,\n    reset,\n  }\n}\n"],"mappings":"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","names":["axios","module","process","import_react","error","import_react","error"]}