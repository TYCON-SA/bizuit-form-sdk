<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test DataService - executeByPageAndName</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 2rem;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .card {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      margin-bottom: 2rem;
    }

    h1 {
      color: #667eea;
      margin-bottom: 1rem;
      font-size: 2rem;
    }

    h2 {
      color: #333;
      margin-bottom: 1.5rem;
      font-size: 1.5rem;
      border-bottom: 2px solid #667eea;
      padding-bottom: 0.5rem;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      font-weight: 600;
      color: #555;
      margin-bottom: 0.5rem;
    }

    input, select {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-size: 1rem;
      transition: border-color 0.3s;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
    }

    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      width: 100%;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .results {
      background: #f8f9fa;
      border-radius: 6px;
      padding: 1rem;
      margin-top: 1rem;
      max-height: 400px;
      overflow-y: auto;
    }

    .results pre {
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }

    .error {
      background: #fee;
      border-left: 4px solid #f44336;
      padding: 1rem;
      border-radius: 6px;
      color: #c62828;
      margin-top: 1rem;
    }

    .success {
      background: #e8f5e9;
      border-left: 4px solid #4caf50;
      padding: 1rem;
      border-radius: 6px;
      color: #2e7d32;
      margin-top: 1rem;
    }

    .info {
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
      padding: 1rem;
      border-radius: 6px;
      color: #1565c0;
      margin-bottom: 1.5rem;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 0.5rem;
      vertical-align: middle;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .metric {
      background: white;
      padding: 1rem;
      border-radius: 6px;
      border: 2px solid #e0e0e0;
    }

    .metric-value {
      font-size: 2rem;
      font-weight: bold;
      color: #667eea;
    }

    .metric-label {
      color: #666;
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      background: white;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    th {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 0.75rem;
      text-align: left;
      font-weight: 600;
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    td {
      padding: 0.75rem;
      border-bottom: 1px solid #e0e0e0;
      color: #333;
    }

    tr:last-child td {
      border-bottom: none;
    }

    tr:hover {
      background-color: #f8f9ff;
    }

    .json-view {
      margin-top: 1rem;
    }

    .json-toggle {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
    }

    .json-toggle:hover {
      background: #eee;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>游빍 Test DataService - executeByPageAndName()</h1>
      <div class="info">
        <strong>Nueva API sin IDs num칠ricos!</strong><br>
        Este test demuestra <code>executeByPageAndName()</code> que permite ejecutar DataServices usando solo nombres descriptivos.
        <br><br>
        <strong>Beneficio de seguridad:</strong> El endpoint /Pages solo retorna p치ginas a las que el usuario tiene acceso,
        proveyendo una capa autom치tica de seguridad.
      </div>

      <h2>Configuraci칩n</h2>
      <div class="form-group">
        <label for="apiUrl">API URL</label>
        <input type="text" id="apiUrl" value="https://test.bizuit.com/recubizBIZUITDashboardAPI/api" placeholder="https://test.bizuit.com/recubizBIZUITDashboardAPI/api">
      </div>

      <div class="form-group">
        <label for="token">Token de Autenticaci칩n</label>
        <input type="text" id="token" placeholder="Peg치 tu token de Dashboard ac치">
      </div>

      <h2>Ejecutar DataService</h2>
      <div class="form-group">
        <label for="pageName">Nombre de P치gina</label>
        <input type="text" id="pageName" value="DataService" placeholder="ej: DataService, Facturas, Clientes">
      </div>

      <div class="form-group">
        <label for="dataServiceName">Nombre del DataService</label>
        <input type="text" id="dataServiceName" value="GetParametersByType" placeholder="ej: GetParametersByType, GetCustomers">
      </div>

      <div class="form-group">
        <label for="parameters">Par치metros (JSON)</label>
        <textarea id="parameters" rows="4" placeholder='[{"name": "typename", "value": "Motivos de Rechazo"}]' style="font-family: monospace; width: 100%; padding: 0.75rem; border: 2px solid #e0e0e0; border-radius: 6px;">[{"name": "typename", "value": "Motivos de Rechazo"}]</textarea>
        <small style="color: #666;">Formato: array de objetos con "name" y "value"</small>
      </div>

      <button id="btnExecute" onclick="executeDataService()">
        Ejecutar DataService
      </button>

      <button id="btnGetPages" onclick="getPages()" style="margin-top: 1rem; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
        Ver P치ginas Disponibles
      </button>
    </div>

    <div class="card" id="resultsCard" style="display: none;">
      <h2>Resultados</h2>
      <div id="metrics" class="grid"></div>
      <div id="results" class="results"></div>
    </div>
  </div>

  <script>
    // Simple BizuitSDK mock for testing
    class BizuitSDK {
      constructor(config) {
        this.config = config
        this.dataService = new BizuitDataServiceService(config)
      }
    }

    class BizuitDataServiceService {
      constructor(config) {
        this.apiUrl = config.apiUrl
      }

      async getPages(token) {
        try {
          const response = await fetch(`${this.apiUrl}/Pages`, {
            headers: {
              'bz-auth-token': `Basic ${token}`,
            },
          })

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
          }

          return await response.json()
        } catch (error) {
          console.error('Error fetching pages:', error)
          throw error
        }
      }

      async findPageByName(pageName, token) {
        const pages = await this.getPages(token)

        // Helper function to search recursively
        const searchInPages = (pageList) => {
          for (const page of pageList) {
            // Check current page
            if (page.tabName === pageName) {
              return page
            }

            // Search in children if they exist
            if (page.children && Array.isArray(page.children) && page.children.length > 0) {
              const found = searchInPages(page.children)
              if (found) {
                return found
              }
            }
          }
          return null
        }

        return searchInPages(pages)
      }

      async getByTabModuleId(tabModuleId, token) {
        try {
          const response = await fetch(
            `${this.apiUrl}/Dashboard/DataService/GetByTabModuleId?tabModuleId=${tabModuleId}`,
            {
              headers: {
                'Authorization': `Basic ${token}`,
              },
            }
          )

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
          }

          const data = await response.json()

          // API returns: { id, tabModuleID, configuration: { grid: [...] } }
          // Extract grid items and convert to DataService list
          if (data && data.configuration && Array.isArray(data.configuration.grid)) {
            return data.configuration.grid.map(item => ({
              id: item.id,
              name: item.title, // 'title' is the DataService name
              tabModuleId: data.tabModuleID,
              uniqueId: item.uniqueId,
              cacheTime: item.cacheTime,
              isGlobalParams: item.isGlobalParams,
              isActive: true,
            }))
          }

          return []
        } catch (error) {
          console.error('Error fetching DataServices:', error)
          return []
        }
      }

      async execute(request, token) {
        const { id, parameters = [], withoutCache = false, executeFromGlobal = false } = request

        const queryParams = new URLSearchParams({
          withoutCache: String(withoutCache),
          executeFromGlobal: String(executeFromGlobal),
        })

        const body = {
          id,
          parameters: parameters.map(p => ({
            name: p.name,
            value: p.value,
            isGroupBy: p.isGroupBy ?? false,
          })),
        }

        try {
          const response = await fetch(
            `${this.apiUrl}/Dashboard/DataService/Execute?${queryParams.toString()}`,
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'bz-auth-token': `Basic ${token}`,
              },
              body: JSON.stringify(body),
            }
          )

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
          }

          const responseData = await response.json()

          // Transform gridData structure to flat array of objects
          let flattenedData = []

          if (responseData.gridData && Array.isArray(responseData.gridData) && responseData.gridData.length > 0) {
            const gridTable = responseData.gridData[0]
            if (gridTable.rows && Array.isArray(gridTable.rows)) {
              flattenedData = gridTable.rows.map(row => {
                const obj = {}
                if (row.columns && Array.isArray(row.columns)) {
                  row.columns.forEach(col => {
                    if (col.columnInfo && col.columnInfo.columnName) {
                      obj[col.columnInfo.columnName] = col.value
                    }
                  })
                }
                return obj
              })
            }
          }

          return {
            data: flattenedData,
            success: true,
          }
        } catch (error) {
          return {
            data: [],
            success: false,
            errorMessage: error.message,
            errorType: error.code || 'FETCH_ERROR',
          }
        }
      }

      async executeByName(request, token) {
        const { tabModuleId, dataServiceName, parameters = [], withoutCache = false, executeFromGlobal = false } = request

        try {
          // 1. Get all DataServices for this tab module
          const dataServices = await this.getByTabModuleId(tabModuleId, token)

          // 2. Find the DataService by name
          const dataService = dataServices.find(ds => ds.name === dataServiceName)

          if (!dataService) {
            return {
              data: [],
              success: false,
              errorMessage: `DataService '${dataServiceName}' not found in tab module ${tabModuleId}`,
              errorType: 'DS_NOT_FOUND',
            }
          }

          // 3. Execute the DataService using its ID
          return await this.execute({
            id: dataService.id,
            parameters,
            withoutCache,
            executeFromGlobal,
          }, token)

        } catch (error) {
          return {
            data: [],
            success: false,
            errorMessage: error.message,
            errorType: error.code || 'ERROR',
          }
        }
      }

      async executeByPageAndName(request, token) {
        const { pageName, dataServiceName, parameters = [], withoutCache = false, executeFromGlobal = false } = request

        try {
          // 1. Find page by name
          const page = await this.findPageByName(pageName, token)

          if (!page) {
            return {
              data: [],
              success: false,
              errorMessage: `Page '${pageName}' not found or user doesn't have access`,
              errorType: 'PAGE_NOT_FOUND',
            }
          }

          // 2. Extract tabModuleID from modules array
          let tabModuleId = null

          // Navigate: page.modules[].modules[].tabModuleID
          if (page.modules && Array.isArray(page.modules)) {
            for (const moduleRow of page.modules) {
              if (moduleRow.modules && Array.isArray(moduleRow.modules)) {
                for (const module of moduleRow.modules) {
                  if (module.tabModuleID) {
                    tabModuleId = module.tabModuleID
                    break
                  }
                }
                if (tabModuleId) break
              }
            }
          }

          if (!tabModuleId) {
            return {
              data: [],
              success: false,
              errorMessage: `No modules found for page '${pageName}'`,
              errorType: 'NO_MODULES_FOUND',
            }
          }

          // 3. Execute DataService by name using the module ID
          return await this.executeByName({
            tabModuleId,
            dataServiceName,
            parameters,
            withoutCache,
            executeFromGlobal,
          }, token)

        } catch (error) {
          return {
            data: [],
            success: false,
            errorMessage: error.message,
            errorType: error.code || 'ERROR',
          }
        }
      }
    }

    let sdk = null

    function initSDK() {
      const apiUrl = document.getElementById('apiUrl').value
      if (!apiUrl) {
        throw new Error('API URL es requerida')
      }

      sdk = new BizuitSDK({ apiUrl })
    }

    function getToken() {
      const token = document.getElementById('token').value
      if (!token) {
        throw new Error('Token es requerido')
      }
      return token
    }

    function showResults(data, metrics = {}) {
      const resultsCard = document.getElementById('resultsCard')
      const resultsDiv = document.getElementById('results')
      const metricsDiv = document.getElementById('metrics')

      resultsCard.style.display = 'block'

      // Show metrics
      if (Object.keys(metrics).length > 0) {
        metricsDiv.innerHTML = Object.entries(metrics).map(([label, value]) => `
          <div class="metric">
            <div class="metric-value">${value}</div>
            <div class="metric-label">${label}</div>
          </div>
        `).join('')
      } else {
        metricsDiv.innerHTML = ''
      }

      // Show data as table if it's an array of objects
      if (Array.isArray(data) && data.length > 0 && typeof data[0] === 'object') {
        const columns = Object.keys(data[0])

        const tableHTML = `
          <table>
            <thead>
              <tr>
                ${columns.map(col => `<th>${col}</th>`).join('')}
              </tr>
            </thead>
            <tbody>
              ${data.map(row => `
                <tr>
                  ${columns.map(col => `<td>${row[col] ?? ''}</td>`).join('')}
                </tr>
              `).join('')}
            </tbody>
          </table>
          <button class="json-toggle" onclick="toggleJSON()">
            Ver JSON
          </button>
          <div id="jsonView" class="json-view" style="display: none;">
            <pre>${JSON.stringify(data, null, 2)}</pre>
          </div>
        `
        resultsDiv.innerHTML = tableHTML
      } else {
        // Show JSON for non-array data
        resultsDiv.innerHTML = `<pre>${JSON.stringify(data, null, 2)}</pre>`
      }

      // Scroll to results
      resultsCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' })
    }

    function toggleJSON() {
      const jsonView = document.getElementById('jsonView')
      const button = event.target

      if (jsonView.style.display === 'none') {
        jsonView.style.display = 'block'
        button.textContent = 'Ocultar JSON'
      } else {
        jsonView.style.display = 'none'
        button.textContent = 'Ver JSON'
      }
    }

    function showError(message) {
      const resultsCard = document.getElementById('resultsCard')
      const resultsDiv = document.getElementById('results')
      const metricsDiv = document.getElementById('metrics')

      resultsCard.style.display = 'block'
      metricsDiv.innerHTML = ''
      resultsDiv.innerHTML = `<div class="error"><strong>Error:</strong> ${message}</div>`

      resultsCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' })
    }

    async function getPages() {
      const btn = document.getElementById('btnGetPages')
      const originalText = btn.innerHTML

      try {
        btn.disabled = true
        btn.innerHTML = '<span class="loading"></span>Cargando p치ginas...'

        initSDK()
        const token = getToken()

        const pages = await sdk.dataService.getPages(token)

        showResults(pages, {
          'Total': pages.length,
          'P치ginas con acceso': pages.length
        })

      } catch (error) {
        showError(error.message)
      } finally {
        btn.disabled = false
        btn.innerHTML = originalText
      }
    }

    async function executeDataService() {
      const btn = document.getElementById('btnExecute')
      const originalText = btn.innerHTML

      try {
        btn.disabled = true
        btn.innerHTML = '<span class="loading"></span>Ejecutando...'

        initSDK()
        const token = getToken()
        const pageName = document.getElementById('pageName').value
        const dataServiceName = document.getElementById('dataServiceName').value
        const parametersText = document.getElementById('parameters').value

        if (!pageName) {
          throw new Error('Nombre de p치gina es requerido')
        }

        if (!dataServiceName) {
          throw new Error('Nombre de DataService es requerido')
        }

        // Parse parameters from JSON
        let parameters = []
        if (parametersText.trim()) {
          try {
            parameters = JSON.parse(parametersText)
            if (!Array.isArray(parameters)) {
              throw new Error('Los par치metros deben ser un array')
            }
          } catch (e) {
            throw new Error(`Error parseando par치metros JSON: ${e.message}`)
          }
        }

        const startTime = performance.now()

        const result = await sdk.dataService.executeByPageAndName({
          pageName,
          dataServiceName,
          parameters,
          withoutCache: false,
          executeFromGlobal: false,
        }, token)

        const endTime = performance.now()
        const duration = Math.round(endTime - startTime)

        if (result.success) {
          showResults(result, {
            'Registros': result.data?.length || 0,
            'Tiempo': `${duration}ms`,
            'Estado': '칄xito'
          })
        } else {
          if (result.errorType === 'PAGE_NOT_FOUND') {
            showError(`La p치gina '${pageName}' no existe o el usuario no tiene acceso a ella. Esto es parte de la seguridad autom치tica del sistema.`)
          } else if (result.errorType === 'NO_MODULES_FOUND') {
            showError(`La p치gina '${pageName}' no tiene m칩dulos configurados. Verifica que la p치gina tenga m칩dulos asignados en Dashboard.`)
          } else if (result.errorType === 'DS_NOT_FOUND') {
            showError(`El DataService '${dataServiceName}' no fue encontrado en la p치gina '${pageName}'.`)
          } else {
            showError(result.errorMessage || 'Error desconocido')
          }
        }

      } catch (error) {
        showError(error.message)
      } finally {
        btn.disabled = false
        btn.innerHTML = originalText
      }
    }

    // Allow Enter key to submit
    document.addEventListener('DOMContentLoaded', () => {
      const inputs = document.querySelectorAll('input')
      inputs.forEach(input => {
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            executeDataService()
          }
        })
      })
    })
  </script>
</body>
</html>
